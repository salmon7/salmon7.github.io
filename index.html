<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="keep running">
<meta property="og:url" content="http://blog.zhang7long.com/index.html">
<meta property="og:site_name" content="keep running">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="keep running">





  
  
  <link rel="canonical" href="http://blog.zhang7long.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>keep running</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c81c2d859c047c5b20dc74f1bd5eb198";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">keep running</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2020/07/12/flink学习系列之一: taskmanager, slot与parallelism.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/12/flink学习系列之一: taskmanager, slot与parallelism.html" class="post-title-link" itemprop="url">flink学习系列之一: taskmanager, slot与parallelism</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-07-12 22:15:43 / Modified: 23:08:59" itemprop="dateCreated datePublished" datetime="2020-07-12T22:15:43+08:00">2020-07-12</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>如无特别说明，本文讨论的内容均基于 flink 1.7.1</p>
</blockquote>
<blockquote>
<p>最近一段时间用 flink 写一些 etl 作业，做数据的收集清洗入库，也遇到一些性能问题需要进一步解决，于是计划学习部分flink底层知识。第一篇，跟以前学习spark一样，从flink的并行度说起。</p>
</blockquote>
<h2 id="flink作业的启动模式"><a href="#flink作业的启动模式" class="headerlink" title="flink作业的启动模式"></a>flink作业的启动模式</h2><p>通过 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/deployment/yarn_setup.html" target="_blank" rel="noopener">flink YARN Setup</a> 文档我们能够了解到，flink的启动方式大致有两种，<br>一种是先分配jobmanager、taskmanager的资源，等待后续提交作业，另一种是在提交的时候申请资源并运行。下面将简单介绍一下这两种启动方式的区别，并着重关注其并行度的计算，最后和spark并行度的计算对对比。</p>
<h3 id="部署方式一：在yarn中启动一个flink-session，提交job到该session"><a href="#部署方式一：在yarn中启动一个flink-session，提交job到该session" class="headerlink" title="部署方式一：在yarn中启动一个flink session，提交job到该session"></a>部署方式一：在yarn中启动一个flink session，提交job到该session</h3><ul>
<li>启动flink session<ul>
<li>./bin/yarn-session.sh -tm 8192 -s 32</li>
<li>关键配置：<ul>
<li>-n，指定 container 数量（即taskmanager的数量，不过已经不建议使用，对应的<a href="https://github.com/apache/flink/blob/release-1.7.1/flink-yarn/src/main/java/org/apache/flink/yarn/cli/FlinkYarnSessionCli.java#L373" target="_blank" rel="noopener">源码</a> </li>
<li>-tm，分配 taskmanager 内存大小</li>
<li>-jm，分配 jobmanager 内存大小</li>
<li>-s，每个taskmanager分配slot个数（如果配置了将会覆盖yarn的 parallelism.default 配置，parallelism.default 值默认为1）</li>
<li>-Dyarn.containers.vcores，在yarn中分配的vcore个数，默认和slot个数一致，即一个slot一个vcore</li>
<li>默认 taskmanager 的数量为1，并行度为 slot * taskmanager ，<a href="https://github.com/apache/flink/blob/release-1.7.1/flink-yarn/src/main/java/org/apache/flink/yarn/cli/FlinkYarnSessionCli.java#L619" target="_blank" rel="noopener">源码</a></li>
</ul>
</li>
<li>一旦 flink session在yarn中启动成功，将会展示有关 jobmanager 连接的详细信息，通过CTRL+C 或者 在client中输入stop关闭 flink session</li>
</ul>
</li>
<li>提交job到该session<ul>
<li>./bin/flink run ./examples/batch/WordCount.jar </li>
<li>关键配置：<ul>
<li>-c，指定入口class</li>
<li>-m，指定jobmanager地址</li>
<li>-p，指定作业的并行度</li>
</ul>
</li>
<li>client能够自动识别对应的 jobmanager 地址</li>
<li>并行度的确定：<ul>
<li>如果不指定 -p ，则作业并行度为 1 （parallelism.default 的配置值，默认为1）</li>
<li>如果指定-p，则作业则在该session下，以 -p 指定值的并行度运行。如果作业的并行度大于session的并行度，则会报异常，作业启动失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="部署方式二：在yarn中启动一个单独的作业"><a href="#部署方式二：在yarn中启动一个单独的作业" class="headerlink" title="部署方式二：在yarn中启动一个单独的作业"></a>部署方式二：在yarn中启动一个单独的作业</h3><ul>
<li>./bin/flink run -m yarn-cluster ./examples/batch/WordCount.jar</li>
<li>flink session的配置同样适用于启动单独的作业，需要加前缀 y 或者 yarn</li>
<li>关键配置：<ul>
<li>-n ，允许加载savepoint失败时启动程序</li>
<li>-d，client非阻塞模式启动作业</li>
<li>-p，指定作业并行度</li>
<li>-ytm，分配 taskmanager 内存大小</li>
<li>-yjm，分配 jobmanager 内存大小</li>
<li>-ys，指定每个taskmanager分配slot个数</li>
<li>-yn，指定container数量，和taskmanager数量一致</li>
</ul>
</li>
<li>并行度的确定<ul>
<li>如果指定了-m yarn-cluster，并且是 -d 或者 -yd 模式，不通过 -yid 指定 applicationid，则其并行度由 -p 决定。</li>
<li>flink会启动多少个taskmanager？我们知道flink作业的实际并行度是由 taskmanager * slot 决定的，默认情况下每个taskmanager的slot数量为1，所以yarn最终为了实现并行度为 -p 的作业，需要启动p个taskmanager。num( taskmanenger ) = p / slot </li>
</ul>
</li>
</ul>
<h2 id="spark-on-yarn-vs-flink-on-yarn"><a href="#spark-on-yarn-vs-flink-on-yarn" class="headerlink" title="spark on yarn vs. flink on yarn"></a>spark on yarn vs. flink on yarn</h2><blockquote>
<p>spark相关的executor以及并行的计算见 Spark学习系列之一和之二</p>
</blockquote>
<ul>
<li>executor vs. taskmanager<ul>
<li>spark submit 通过 –num-executors 控制executor数量</li>
<li>flink run 通过 -p 和 -ys 控制taskmanager数量</li>
</ul>
</li>
</ul>
<blockquote>
<p>另外spark on standalone模式下，其executor数量的计算方式和flink run差不多，它也是通过总的核数和每个executor核数反算所需的executor数目，可以把 total-executor-cores 类比 -p，executor-cores 类比 -ys）</p>
</blockquote>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2020/07/12/flink学习系列之一: taskmanager, slot与parallelism.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2020/07/05/es学习系列之二：Aggregation-Optimization.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/05/es学习系列之二：Aggregation-Optimization.html" class="post-title-link" itemprop="url">es学习系列之二：Aggregation Optimization</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-07-05 16:59:15" itemprop="dateCreated datePublished" datetime="2020-07-05T16:59:15+08:00">2020-07-05</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-07-12 23:12:22" itemprop="dateModified" datetime="2020-07-12T23:12:22+08:00">2020-07-12</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>如无特别说明，本文讨论的内容均基于 es 7.*</p>
</blockquote>
<h2 id="20w-s-ops索引的聚合"><a href="#20w-s-ops索引的聚合" class="headerlink" title="20w/s ops索引的聚合"></a>20w/s ops索引的聚合</h2><p>我们有个常用的查询入口，默认根据查询条件聚合某个id近1小时的数据（每条聚合结果大部分情况下文档数量为1），再根据id去es里面查找对应的文档（一个id可能对应多个文档）</p>
<h3 id="集群基础情况-amp-amp-索引关键配置"><a href="#集群基础情况-amp-amp-索引关键配置" class="headerlink" title="集群基础情况 &amp;&amp; 索引关键配置"></a>集群基础情况 &amp;&amp; 索引关键配置</h3><ul>
<li><p>集群的节点分布</p>
<ul>
<li>2 client</li>
<li>3 master</li>
<li>26 ssd机器</li>
<li>5 sata机器</li>
</ul>
</li>
<li><p>索引配置</p>
<ul>
<li>25个shard，1个replica</li>
<li>refresh interval 配置为 60s，即”index.refresh_interval”: “60s”</li>
<li>主shard 8TB/天，加上replica约16TB/天</li>
<li>日志量峰值 20w/s，主shard索引速度峰值 20w/s，加上replica约40w/s</li>
</ul>
</li>
</ul>
<h3 id="优化一：时间序列索引的时间条件"><a href="#优化一：时间序列索引的时间条件" class="headerlink" title="优化一：时间序列索引的时间条件"></a>优化一：时间序列索引的时间条件</h3><p>对于时间序列的索引，我们搜索时一般都都需要加上末尾加上 <code>*</code> 进行匹配，如<code>nginx_log-*</code>，这时我们需要在query中添加时间range条件，这样es会自动过滤不符合时间条件的索引，减少查询数量，<br>否则会匹配索所有的索引，如果数据量很大的话，会减慢查询速度。</p>
<h3 id="优化二：refresh-interval-对-golbal-ordinal的影响"><a href="#优化二：refresh-interval-对-golbal-ordinal的影响" class="headerlink" title="优化二：refresh interval 对 golbal ordinal的影响"></a>优化二：refresh interval 对 golbal ordinal的影响</h3><h4 id="生成-segment-的条件"><a href="#生成-segment-的条件" class="headerlink" title="生成 segment 的条件"></a>生成 segment 的条件</h4><ol>
<li>index buffer 被占满，默认为jvm的10% <a href="https://elastic.co/guide/en/elasticsearch/reference/7.2/indexing-buffer.html" target="_blank" rel="noopener">https://elastic.co/guide/en/elasticsearch/reference/7.2/indexing-buffer.html</a> </li>
<li>每 refresh 一次就生成一个segment。(merge操作会定时合并小的segments为大的segment，保持segments在一定的数量范围内，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/index-modules-merge.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.2/index-modules-merge.html</a>)</li>
<li>查看 segments 的数量：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 发出查询后，在30s内，均能看对应的segment的变化，超过30s后如果没有新请求，则不会进行refresh（30s 是通过 index.search.idle.after 配置的，兼顾查询速度和减少segment增长数量）</span><br><span class="line"># https://www.elastic.co/guide/en/elasticsearch/reference/7.4/cluster-nodes-stats.html</span><br><span class="line">GET /_nodes/stats/indices/segments?level=indices&amp;nodeId=xxxx</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"># 这个会比较延迟一点，不过segments情况更加详细，包括了总的（即可查询）的segments以及提交了segments</span><br><span class="line"># https://www.elastic.co/guide/en/elasticsearch/reference/7.2/indices-segments.html</span><br><span class="line">GET nginx_log-2020.07.05-000023/_segments</span><br></pre></td></tr></table></figure>
<h4 id="global-ordinal"><a href="#global-ordinal" class="headerlink" title="global ordinal"></a>global ordinal</h4><p>1.对于keyword等类型，es为了节省内存空间，在 <strong>segment</strong> 层面使用了根据自增整数或者词典顺序生成的 <strong>序数</strong> 代表每个keyword值。假设keyword类型字段msg，有一个文档的msg=”hello”，<br>其对应的序数为12345，这样对于每个文档对应的keyword字段如果为”hello”存的就是1234。<br>如果hello在mesg字段中重复多次，那么每个文档msg字段的docvalues只要存 12345 即可。简化计算方式，相比48个字节的hello，存储12345只要32个字节。为了便于理解，下面给了两个简单的例子，第一个是我们直观的存储，第二个是es实际的数据结构。</p>
<table>
<thead>
<tr>
<th>doc_id</th>
<th>msg: doc values</th>
</tr>
</thead>
<tbody>
<tr>
<td>doc_1</td>
<td>“hello”, “world”</td>
</tr>
<tr>
<td>doc_2</td>
<td>“hello”</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>doc_id</th>
<th>msg: doc values</th>
</tr>
</thead>
<tbody>
<tr>
<td>doc_1</td>
<td>12345, 45678</td>
</tr>
<tr>
<td>doc_2</td>
<td>12345</td>
</tr>
</tbody>
</table>
<p>2.现在我们知道doc value中存的都是序数，那么在单个shard聚合msg字段的时候，只要把相同的序数放到同一个桶即可，这样可以加快聚合速度，最后返回的时候把序数替换成对应的值即可。但是序数是基于segment的，同一个字符串在不同segment的序数可能不同，<br>因此需要一个在所有的segment之上构建一个 global ordinal map。如：  </p>
<table>
<thead>
<tr>
<th>segment_id</th>
<th>doc_id</th>
<th>msg: doc values</th>
</tr>
</thead>
<tbody>
<tr>
<td>seg_1</td>
<td>doc_1</td>
<td>12345, 45678</td>
</tr>
<tr>
<td>seg_1</td>
<td>doc_2</td>
<td>12345</td>
</tr>
<tr>
<td>seg_2</td>
<td>doc_3</td>
<td>54321, 87654</td>
</tr>
<tr>
<td>seg_2</td>
<td>doc_4</td>
<td>54321</td>
</tr>
</tbody>
</table>
<p>global ordinal map:<br>seg_1: 12345 -&gt; hello, 45678 -&gt; world<br>seg_2: 54321 -&gt; hello, 87654 -&gt; world</p>
<p>3.global ordinal的构建/维持逻辑</p>
<ul>
<li>构建 global ordinal map可能很耗时<ul>
<li>如果shard很大，对应的聚合字段可能会包含很多不同类型的值，则构建gloabl ordinal map可能会很耗时</li>
<li>同理，如果对应的聚合字段为大量的唯一值（比如requestID，在一定时间内几乎不可能相同），那么构建global ordinal map也会很耗费资源</li>
<li>小结：构建 global ordinal 比传输字段原始值更耗资源，比如上面的msg字段有5w个唯一的值，并且平均分布在5个segment中，那么需要考虑两种方法：第一种，根据每个segment的ordinal map构建size大小为5w的global ordinal map后，再根据global ordinal聚合得到聚合结果，最后转为原始值返回；第二种，直接把这5w个ordinal转为原始值，直接聚合。</li>
</ul>
</li>
<li>global orinal map 可能会失效<ul>
<li>因为global ordinals为分片上的所有segments提供了统一的mapping，所以当一个新的segment变为可见时，还需要完全重建它们。（Because global ordinals provide a unified mapping for all segments on the shard, they also need to be rebuilt entirely when a new segment becomes visible. ）</li>
<li>小结：对于refresh interval比较小的索引，每次聚合查询都会重新构建 global ordinla map。</li>
</ul>
</li>
</ul>
<p>global ordinal<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/tune-for-search-speed.html#_warm_up_global_ordinals" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.2/tune-for-search-speed.html#_warm_up_global_ordinals</a></p>
<p>eager_global_ordinals<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/eager-global-ordinals.html#eager-global-ordinals" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.2/eager-global-ordinals.html#eager-global-ordinals</a></p>
<ul>
<li>25个shard<br>1.说明基础情况，数据量级，node情况<br>2.refresh interval，60s，时间序列情况<br>3.优化情况</li>
</ul>
<p>为了避免 shard cache 对聚合结果的影响，我们在聚合时带上request_cache=false 参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"># 观察 global ordinal map耗费的资源</span><br><span class="line">GET /_nodes/stats/indices/fielddata?level=indices&amp;fields=traceID</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">        &quot;tracing_common_lbc_jaeger_span-2020.07.05-000204&quot; : &#123;</span><br><span class="line">            &quot;fielddata&quot; : &#123;</span><br><span class="line">              &quot;memory_size_in_bytes&quot; : 10120,</span><br><span class="line">              &quot;evictions&quot; : 0,</span><br><span class="line">              &quot;fields&quot; : &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line"># 可以看到，es并没有提交为 traceID 提前创建 global ordinals </span><br><span class="line"></span><br><span class="line"># 观察数据大小</span><br><span class="line"># 13:00-14:00 数据数目为541948948，约5.4亿条</span><br><span class="line">GET /tracing_common_lbc_jaeger_span-2020.07.05-000204/_count</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;range&quot;: &#123;</span><br><span class="line">            &quot;startTimeMillis&quot;: &#123;</span><br><span class="line">              &quot;from&quot;: 1593925200000,</span><br><span class="line">              &quot;include_lower&quot;: true,</span><br><span class="line">              &quot;include_upper&quot;: true,</span><br><span class="line">              &quot;to&quot;: 1593928800000</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;process.serviceName&quot;: &#123;</span><br><span class="line">              &quot;query&quot;: &quot;lbc&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">返回：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;count&quot; : 541948948,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 25,</span><br><span class="line">    &quot;successful&quot; : 25,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 执行聚合，耗时约 40s </span><br><span class="line">GET /tracing_common_lbc_jaeger_span-2020.07.05-000204/_search?request_cache=false</span><br><span class="line">&#123;</span><br><span class="line">    &quot;took&quot;: 39407,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 25,</span><br><span class="line">        &quot;successful&quot;: 25,</span><br><span class="line">        &quot;skipped&quot;: 0,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hits&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: &#123;</span><br><span class="line">            &quot;value&quot;: 10000,</span><br><span class="line">            &quot;relation&quot;: &quot;gte&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;max_score&quot;: null,</span><br><span class="line">        &quot;hits&quot;: []</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;aggregations&quot;: &#123;</span><br><span class="line">        &quot;traceIDs&quot;: &#123;</span><br><span class="line">            .......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 执行聚合后，观察 ordinal 的数量，48mb的缓存</span><br><span class="line">GET /_nodes/stats/indices/fielddata?level=indices&amp;fields=traceID</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">          &quot;tracing_common_lbc_jaeger_span-2020.07.05-000204&quot; : &#123;</span><br><span class="line">            &quot;fielddata&quot; : &#123;</span><br><span class="line">              &quot;memory_size_in_bytes&quot; : 406626768,</span><br><span class="line">              &quot;evictions&quot; : 0,</span><br><span class="line">              &quot;fields&quot; : &#123;</span><br><span class="line">                &quot;traceID&quot; : &#123;</span><br><span class="line">                  &quot;memory_size_in_bytes&quot; : 406616120</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br></pre></td></tr></table></figure>
<h2 id="Index-Lifecycle-Management"><a href="#Index-Lifecycle-Management" class="headerlink" title="Index Lifecycle Management"></a>Index Lifecycle Management</h2><p>cdn索引的优化：</p>
<h2 id="聚合查询的优化"><a href="#聚合查询的优化" class="headerlink" title="聚合查询的优化"></a>聚合查询的优化</h2><p>1.refresh interval<br>2.shard request cache<br>3.global ordinal 的影响<br>4.shard数量的影响<br>5.时间序列的影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 查看对应的 global ordinal 占用的内存（对于keyword类型，fieldata就是其global ordinal占用的内存）</span><br><span class="line">GET /_nodes/stats/indices/fielddata?level=indices&amp;fields=traceID</span><br><span class="line"></span><br><span class="line">          &quot;tracing_common_cdn_jaeger_span-2020.07.01-000019&quot; : &#123;</span><br><span class="line">            &quot;fielddata&quot; : &#123;</span><br><span class="line">              &quot;memory_size_in_bytes&quot; : 258403624,</span><br><span class="line">              &quot;evictions&quot; : 0,</span><br><span class="line">              &quot;fields&quot; : &#123;</span><br><span class="line">                &quot;traceID&quot; : &#123;</span><br><span class="line">                  &quot;memory_size_in_bytes&quot; : 258401160</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          &quot;tracing_common_cdn_jaeger_span-2020.07.01-000019&quot; : &#123;</span><br><span class="line">            &quot;fielddata&quot; : &#123;</span><br><span class="line">              &quot;memory_size_in_bytes&quot; : 263655552,</span><br><span class="line">              &quot;evictions&quot; : 0,</span><br><span class="line">              &quot;fields&quot; : &#123;</span><br><span class="line">                &quot;traceID&quot; : &#123;</span><br><span class="line">                  &quot;memory_size_in_bytes&quot; : 263652224</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&quot;tracing_common_cdn_jaeger_span-2020.07.01-000019&quot; : &#123;</span><br><span class="line">  &quot;fielddata&quot; : &#123;</span><br><span class="line">    &quot;memory_size_in_bytes&quot; : 258403624,</span><br><span class="line">    &quot;evictions&quot; : 0,</span><br><span class="line">    &quot;fields&quot; : &#123;</span><br><span class="line">      &quot;traceID&quot; : &#123;</span><br><span class="line">        &quot;memory_size_in_bytes&quot; : 258401160</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&quot;tracing_common_cdn_jaeger_span-2020.07.01-000019&quot; : &#123;</span><br><span class="line">  &quot;fielddata&quot; : &#123;</span><br><span class="line">    &quot;memory_size_in_bytes&quot; : 263655552,</span><br><span class="line">    &quot;evictions&quot; : 0,</span><br><span class="line">    &quot;fields&quot; : &#123;</span><br><span class="line">      &quot;traceID&quot; : &#123;</span><br><span class="line">        &quot;memory_size_in_bytes&quot; : 263652224</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="改成filter-能否领用-node-query-cache"><a href="#改成filter-能否领用-node-query-cache" class="headerlink" title="改成filter 能否领用 node query cache"></a>改成filter 能否领用 node query cache</h2><blockquote>
<p>本文为学习过程中产生的总结，由于学艺不精可能有些观点或者描述有误，还望各位同学帮忙指正，共同进步。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2020/05/17/es学习系列之一：Rollover-Index-VS-Index-Lifecycle-Management.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/17/es学习系列之一：Rollover-Index-VS-Index-Lifecycle-Management.html" class="post-title-link" itemprop="url">es学习系列之一：Rollover Index VS. Index Lifecycle Management</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-05-17 16:40:19" itemprop="dateCreated datePublished" datetime="2020-05-17T16:40:19+08:00">2020-05-17</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-08-08 15:17:48" itemprop="dateModified" datetime="2020-08-08T15:17:48+08:00">2020-08-08</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>如无特别说明，本文讨论的内容均基于 es 7.*</p>
</blockquote>
<h2 id="es的Rollover索引"><a href="#es的Rollover索引" class="headerlink" title="es的Rollover索引"></a>es的Rollover索引</h2><p>es的Rollover索引通常指的是一个别名指向某个索引，并且能够在索引的某些条件下进行轮转，如索引的创建时间长短、大小、文档数量。</p>
<p>如创建一个名为 nginx_log-000001 的索引，并指定其alias为nginx_log_write，并且我们对nginx_log_write写入3个文档（其实也是对nginx_log-000001写）。然后对别名调用rollover接口，<br>由于已经达到文档数目为3的条件，则会自动生成 nginx_log-000002 的索引。这时对nginx_log_write写入会自动写入到nginx_log-000002索引中。</p>
<p>需要注意的是，由于对索引设置alias的时候，没有添加 <code>&quot;is_write_index&quot;: true</code> 配置，则在执行rollover并创建新索引成功后，将会只指向<strong>一个</strong>索引（新索引），对nginx_log_write查询只能查到最新索引的数据，而不能查到历史数据。相反，如果配置了<code>&quot;is_write_index&quot;: true</code>，在rollover后alias会<strong>同时</strong>指向多个索引，并且最新索引设置为<code>&quot;is_write_index&quot;: true</code>，旧索引设置为<code>&quot;is_write_index&quot;: false</code>，对alias的<br>写入就是对最新索引的写入，查询时是对所有索引进行<strong>查询</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># 创建索引nginx_log-000001，并设置其别名为nginx_log_write</span><br><span class="line">PUT /nginx_log-000001</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aliases&quot;: &#123;</span><br><span class="line">    &quot;nginx_log_write&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 对别名写入文档，重复执行3次</span><br><span class="line">POST nginx_log_write/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;log&quot;:&quot;something before rollover&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 对别名执行rollover</span><br><span class="line">POST /nginx_log_write/_rollover</span><br><span class="line">&#123;</span><br><span class="line">  &quot;conditions&quot;: &#123;</span><br><span class="line">    &quot;max_age&quot;:   &quot;1d&quot;,</span><br><span class="line">    &quot;max_docs&quot;:  3,</span><br><span class="line">    &quot;max_size&quot;:  &quot;5gb&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 对新索引插入新数据</span><br><span class="line">POST nginx_log_write/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;log&quot;:&quot;something after rollover&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 分别查 nginx_log-000001、nginx_log-000002、nginx_log_write，对ginx_log_write只能查到最新索引的数据</span><br><span class="line">POST nginx_log_write/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 对非 &quot;is_write_index&quot;: true 模式的索引，可用 index_name-* 查询所有数据</span><br><span class="line">POST nginx_log-*/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，我们可以利用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/date-math-index-names.html" target="_blank" rel="noopener">Date Math</a> 创建带日期的rollover索引，更加方便索引管理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># PUT /&lt;nginx_log-&#123;now/d&#125;-000001&gt;，将创建名为 nginx_log-2020.05.17-000001 的索引</span><br><span class="line">PUT /%3Cnginx_log-%7Bnow%2Fd%7D-000001%3E</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aliases&quot;: &#123;</span><br><span class="line">    &quot;nginx_log_write&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是 <code>_rollover</code> api只会对调用该接口的那个时刻有效，当然可以自己独立做一个任务周期性扫描所有别名，当别名到达一定条件后就调用其 <code>_rollover</code> 接口。如果需要es自身定时调用的话，可以使用自动化程度更高的 Index Lifecycle Management。</p>
<h2 id="Index-Lifecycle-Management"><a href="#Index-Lifecycle-Management" class="headerlink" title="Index Lifecycle Management"></a>Index Lifecycle Management</h2><p>与 _rollover 索引相比，索引生命周期管理会更加自动化，ILM把索引的生命周期分为4个phase，分别为Hot、Warm、Cold、Delete。每个phase可以包含多个action。</p>
<table>
<thead>
<tr>
<th>action</th>
<th>允许该action的phase</th>
<th>action意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rollover</td>
<td>hot</td>
<td>和 rollover 索引的条件一致</td>
</tr>
<tr>
<td>Read-Only</td>
<td>warm</td>
<td>通过<code>&quot;index.blocks.write&quot;: false</code> 把原索引会被设置只读</td>
</tr>
<tr>
<td>Allocation</td>
<td>warm, cold</td>
<td>移动索引时指定的亲和性规则，包括include, exclude, require。同时还可以通过 number_of_replicas 变更副本数量，比如指定为0。</td>
</tr>
<tr>
<td>Shrink</td>
<td>warm</td>
<td>合并shard，创建 shrink-${origin_index_name}，前提是需要把原索引的shard移动到同一个node上，需要留意node是否有足够的容量。并且会通过<code>&quot;index.blocks.write&quot;: false</code> 把原索引会被设置只读，并最终删除原索引。</td>
</tr>
<tr>
<td>Force Merge</td>
<td>warm</td>
<td>合并segmemt。和shrink一样，会通过<code>&quot;index.blocks.write&quot;: false</code> 把原索引会被设置只读</td>
</tr>
<tr>
<td>Freeze</td>
<td>cold</td>
<td>冻结索引。适用于很少查询的旧索引，es通过冻结索引能够减少堆内存的使用</td>
</tr>
<tr>
<td>Delete</td>
<td>delete</td>
<td>删除索引</td>
</tr>
<tr>
<td>Set Priority</td>
<td>hot, warm, cold</td>
<td>重启时，恢复索引的优先度，值越大越优先恢复</td>
</tr>
<tr>
<td>Unfollow</td>
<td>hot,warm,cold</td>
<td>应该是中间状态</td>
</tr>
</tbody>
</table>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2020/05/17/es学习系列之一：Rollover-Index-VS-Index-Lifecycle-Management.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2020/01/02/Spark学习系列之三：join的宽依赖vs-窄依赖.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/02/Spark学习系列之三：join的宽依赖vs-窄依赖.html" class="post-title-link" itemprop="url">Spark学习系列之三：join的宽依赖vs.窄依赖</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-01-02 01:30:54" itemprop="dateCreated datePublished" datetime="2020-01-02T01:30:54+08:00">2020-01-02</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-17 14:32:49" itemprop="dateModified" datetime="2020-05-17T14:32:49+08:00">2020-05-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>如无特别说明，本文源码版本为 spark 2.3.4<br>两个rdd join时产生新的rdd，是宽依赖，还是窄依赖？</p>
</blockquote>
<h2 id="join-transformation"><a href="#join-transformation" class="headerlink" title="join transformation"></a>join transformation</h2><p><img src="/2020/01/02/Spark学习系列之三：join的宽依赖vs-窄依赖/narrow_wide_dependency.png" alt="narrow_wide_dependency.png"></p>
<p>以上图片是个经常用来解释宽窄依赖的经典图，来源于论文&lt;&lt;Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing&gt;&gt;。以下这段话也来自与该论文：</p>
<blockquote>
<p>join: Joining two RDDs may lead to either two nar- row dependencies (if they are both hash/range partitioned with the same partitioner), two wide dependencies, or a mix (if one parent has a partitioner and one does not). In either case, the output RDD has a partitioner (either one inherited from the parents or a default hash partitioner)</p>
</blockquote>
<p>或许我们会好奇，为什么同样是join操作，有时是宽依赖，有时窄依赖？我们先从两个简单的实验开始，再从源码看其实现方式。</p>
<h3 id="rdd1和rdd2的partitioner不同"><a href="#rdd1和rdd2的partitioner不同" class="headerlink" title="rdd1和rdd2的partitioner不同"></a>rdd1和rdd2的partitioner不同</h3><p>假设我们有rdd1和rdd2，其partitioner分别为partitioner1、partitioner2。分区器定义如下：   </p>
<p>partitioner1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numPartiton = 3</span><br><span class="line">func = x mod numPartiton</span><br></pre></td></tr></table></figure>
<p>partitioner2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numPartiton = 5</span><br><span class="line">func = (x  * 3) mod numPartiton</span><br></pre></td></tr></table></figure>
<p>rdd1的初始分布如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">partition0: (0, &quot;a&quot;), (3, &quot;e&quot;)</span><br><span class="line">partition1: (1, &quot;b&quot;)</span><br><span class="line">partition2: (2, &quot;c&quot;)</span><br></pre></td></tr></table></figure>
<p>rdd2的初始分布如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">partition0: (0, &quot;e&quot;), (0, &quot;j&quot;)</span><br><span class="line">partition1: (2, &quot;f&quot;)</span><br><span class="line">partition2: (4, &quot;g&quot;)</span><br><span class="line">partition3: (1, &quot;h&quot;), (6, &quot;k&quot;)</span><br><span class="line">partition4: (3, &quot;i&quot;)</span><br></pre></td></tr></table></figure>
<p>rdd3=rdd2.join(rdd1)，rdd3数据分布如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">partition0: (0, (&quot;e&quot;, &quot;a&quot;)), (0, (&quot;j&quot;, &quot;a&quot;))</span><br><span class="line">partition1: (2, (&quot;f&quot;, &quot;c&quot;))</span><br><span class="line">partition2: </span><br><span class="line">partition3: (1, (&quot;h&quot;, &quot;b&quot;))</span><br><span class="line">partition4: (3, (&quot;i&quot;, &quot;e&quot;))</span><br></pre></td></tr></table></figure>
<p>rdd3和rdd1以及rdd2的parittion之间的依赖关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rdd1.partition0 ==&gt; rdd3.partition0, rdd3.partition4 </span><br><span class="line">rdd1.partition1 ==&gt; rdd3.partition3  </span><br><span class="line">rdd1.partition2 ==&gt; rdd3.partition2  </span><br><span class="line"></span><br><span class="line">rdd2.partition0 ==&gt; rdd3.partition0  </span><br><span class="line">rdd2.partition1 ==&gt; rdd3.partition1 </span><br><span class="line">rdd2.partition2 ==&gt; rdd3.partition2  </span><br><span class="line">rdd2.partition3 ==&gt; rdd3.partition3  </span><br><span class="line">rdd2.partition4 ==&gt; rdd3.partition4</span><br></pre></td></tr></table></figure>
<p>可以看到rdd1的parittion0 同时被rdd3的partition0和partition4依赖，父rdd的一个parittion被子rdd多个parittion依赖，所以此时rdd3对rdd1的依赖为宽依赖，而对rdd2为窄依赖。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2020/01/02/Spark学习系列之三：join的宽依赖vs-窄依赖.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2019/12/23/使用dbutils作为pymysql的连接池时，setsession偶尔失效的问题.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/23/使用dbutils作为pymysql的连接池时，setsession偶尔失效的问题.html" class="post-title-link" itemprop="url">使用dbutils作为pymysql的连接池时，setsession偶尔失效的问题</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-23 00:03:14" itemprop="dateCreated datePublished" datetime="2019-12-23T00:03:14+08:00">2019-12-23</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-17 14:32:49" itemprop="dateModified" datetime="2020-05-17T14:32:49+08:00">2020-05-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>版本情况dbutils:1.1; pymysql:0.9.3; python:2.7.13</p>
</blockquote>
<h2 id="线上情景"><a href="#线上情景" class="headerlink" title="线上情景"></a>线上情景</h2><p>最近线上维护时，由于只需要更改数据库配置，所以就重启了数据库，而python应用没有重启。在重启数据库后，日志显示正常，也能成功入库。后来接到反馈表示有部分数据没有入库，紧急重启python应用，后续数据入库正常。而我则负责找出原因以及修复bug的工作。</p>
<h2 id="调研原因"><a href="#调研原因" class="headerlink" title="调研原因"></a>调研原因</h2><p>在排查完其他问题后，最异常的是对于有部分请求，日志显示处理成功了，但是却没入库，排查了好几天找不到原因。为此写了demo来帮助排查，为了可以自动commit，采用的是setsession=[“set autocommit=1”]方式设置每个底层的连接为自动提交。在测试demo期间，数据库重启后之后的sql就无法入库。demo代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">from</span> DBUtils.PooledDB <span class="keyword">import</span> PooledDB</span><br><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> MySQLError</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br><span class="line">con = <span class="keyword">None</span></span><br><span class="line">pooledDB = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_insert</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"============ &#123;0&#125; ============"</span>.format(i)</span><br><span class="line">        <span class="comment"># 除了第一次从库中拿，不用ping，直接接初始化链接</span></span><br><span class="line">        <span class="comment"># 后面如果有cache connection，则从cache中并且进行ping，如果失败则用_create()重新初始化connection</span></span><br><span class="line">        <span class="comment"># con 类型为 PooledDedicatedDBConnection</span></span><br><span class="line">        <span class="comment"># con._con 类型为 SteadyDBConnection</span></span><br><span class="line">        <span class="comment"># con._con._con 类型为 pymysql中的Connection类型</span></span><br><span class="line">        <span class="comment"># con._con._con._sock 类型为 mysql 连接</span></span><br><span class="line">        con = pooledDB.connection()</span><br><span class="line">        <span class="comment"># con._con._con.autocommit(True)</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"con._con id = &#123;0&#125;"</span>.format(id(con._con))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"con._con._con id = &#123;0&#125;"</span>.format(id(con._con._con))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"con._con._con._sock id = &#123;0&#125;"</span>.format(id(con._con._con._sock))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor = con.cursor(pymysql.cursors.DictCursor)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cursor:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"cursor is &#123;0&#125;"</span>.format(cursor)</span><br><span class="line">            select_sql = <span class="string">"insert into user2(name,age) values('zhang', 20)"</span></span><br><span class="line">            ret_rows = cursor.execute(select_sql)</span><br><span class="line">            <span class="keyword">print</span> cursor._last_executed</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"ret_rows is &#123;0&#125;"</span>.format(ret_rows)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> MySQLError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"MySQLError error: &#123;0&#125;"</span>.format(e)</span><br><span class="line">            <span class="keyword">print</span> traceback.format_exc()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"Exception error: &#123;0&#125;"</span>.format(e)</span><br><span class="line">            <span class="keyword">print</span> traceback.format_exc()</span><br><span class="line"></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        con.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    db_conf = &#123;<span class="string">'user'</span>:<span class="string">'root'</span>,<span class="string">'passwd'</span>:<span class="string">'zhang'</span>,<span class="string">'host'</span>:<span class="string">'127.0.0.1'</span>,<span class="string">'port'</span>:<span class="number">3306</span>,<span class="string">'connect_timeout'</span>:<span class="number">5</span>,<span class="string">'db'</span>:<span class="string">'test_dbutils'</span>&#125;</span><br><span class="line">    <span class="comment"># db_conf = &#123;'user':'root','passwd':'zhang','host':'127.0.0.1','port':3306,'connect_timeout':5,'db':'test_dbutils',"autocommit":True&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pooledDB = PooledDB(</span><br><span class="line">        creator=pymysql,  <span class="comment"># 使用数据库连接的模块</span></span><br><span class="line">        maxconnections=<span class="number">4</span>,  <span class="comment"># 连接池允许的最大连接数，0和None表示不限制连接数</span></span><br><span class="line">        mincached=<span class="number">0</span>,  <span class="comment"># 初始化时，连接池中至少创建的空闲的链接，0表示不创建</span></span><br><span class="line">        maxcached=<span class="number">0</span>,  <span class="comment"># 连接池中最多闲置的链接，0和None不限制</span></span><br><span class="line">        maxshared=<span class="number">0</span>,  <span class="comment"># 连接池中最多共享的链接数量，0表示不共享。PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，此值只有在creator.threadsafety &gt; 1时设置才有效，否则创建的都是dedicated connection，即此连接是线程专用的。</span></span><br><span class="line">        blocking=<span class="keyword">True</span>,  <span class="comment"># 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错</span></span><br><span class="line">        maxusage=<span class="keyword">None</span>,  <span class="comment"># 一个连接最多被重复使用的次数，None表示无限制</span></span><br><span class="line">        setsession=[<span class="string">"set autocommit=1"</span>],  <span class="comment"># 开始会话前执行的命令列表。如：["set datestyle to ...", "set time zone ..."]；务必要设置autocommit，否则可能导致该session的sql未提交</span></span><br><span class="line">        ping=<span class="number">1</span>,  <span class="comment"># 每次从pool中取连接时ping一次检查可用性</span></span><br><span class="line">        reset=<span class="keyword">False</span>,  <span class="comment"># 每次将连接放回pool时，将未提交的内容回滚；False时只对事务操作进行回滚</span></span><br><span class="line">        **db_conf</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    try_insert()</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/12/23/使用dbutils作为pymysql的连接池时，setsession偶尔失效的问题.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2019/12/22/Spark学习系列之二：rdd分区数量分析.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/22/Spark学习系列之二：rdd分区数量分析.html" class="post-title-link" itemprop="url">Spark学习系列之二：rdd分区数量分析</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-22 01:43:42" itemprop="dateCreated datePublished" datetime="2019-12-22T01:43:42+08:00">2019-12-22</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-17 14:32:49" itemprop="dateModified" datetime="2020-05-17T14:32:49+08:00">2020-05-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>如无特别说明，本文源码版本为 spark 2.3.4</p>
</blockquote>
<p>创建rdd有三种方式，一种是通过SparkContext.textFile()访问外部存储创建，一种是通过输入数据集合通过调用 SparkContext.parallelize() 方法来创建，最后一种是通过转换已有的rdd生成新的rdd。</p>
<h2 id="通过parallelize创建rdd的分区数量分析"><a href="#通过parallelize创建rdd的分区数量分析" class="headerlink" title="通过parallelize创建rdd的分区数量分析"></a>通过parallelize创建rdd的分区数量分析</h2><p>通过parallelize的方式比较简单，相信也是大部分初学者第一次接触创建rdd的方法，那么通过这个方法创建的rdd的默认分区数是多少呢？我们通过源码进行分析。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.spark.<span class="type">SparkContext</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparkContext</span>(<span class="params">config: <span class="type">SparkConf</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Default level of parallelism to use when not given by user (e.g. parallelize and makeRDD). */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">defaultParallelism</span></span>: <span class="type">Int</span> = &#123;</span><br><span class="line">    assertNotStopped()</span><br><span class="line">    taskScheduler.defaultParallelism</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parallelize</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      seq: <span class="type">Seq</span>[<span class="type">T</span>],</span><br><span class="line">      numSlices: <span class="type">Int</span> = defaultParallelism): <span class="type">RDD</span>[<span class="type">T</span>] = withScope &#123;</span><br><span class="line">    assertNotStopped()</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ParallelCollectionRDD</span>[<span class="type">T</span>](<span class="keyword">this</span>, seq, numSlices, <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">String</span>]]())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看看parallelize是如何生成rdd的。可以看到它是通过 ParallelCollectionRDD 类创建一个rdd，其内部返回的partitioner是通过ParallelCollectionRDD伴生对象的slice方法分割seq为一个二维的Seq[Seq[T]]，并把这个二维的序列传递到ParallelCollectionPartition中实例化的。</p>
<p>接下来是关键，<code>defaultParallelism</code>的默认值确定了分区的数量。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/12/22/Spark学习系列之二：rdd分区数量分析.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2019/12/16/Spark学习系列之一：新手常见问题.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/16/Spark学习系列之一：新手常见问题.html" class="post-title-link" itemprop="url">Spark学习系列之一：新手常见问题</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-16 02:00:19" itemprop="dateCreated datePublished" datetime="2019-12-16T02:00:19+08:00">2019-12-16</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-17 14:32:49" itemprop="dateModified" datetime="2020-05-17T14:32:49+08:00">2020-05-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>如无特别说明，本文源码版本为 spark 2.3.4</p>
</blockquote>
<p>学习spark有一段时间了，最近想动动手写个<a href="https://github.com/salmon7/spark-and-scala-learning" target="_blank" rel="noopener">demo</a>出来，大致的功能是从kafka读取用户点击记录，用spark streaming对这些数据进行读取并统计用户一段时间的点击记录，期望最后能落盘到redis中供需求方调用。</p>
<p>这个demo看似简单，但是作为一个新手，我也遇到了一些看起来比较奇怪的问题。再此总结一下我遇到的一些问题，希望能给遇到同样问题的人带来一些帮助。</p>
<h2 id="问题一：spark的并行度是多少？"><a href="#问题一：spark的并行度是多少？" class="headerlink" title="问题一：spark的并行度是多少？"></a>问题一：spark的并行度是多少？</h2><p>我相信一开始接触的初学者对此肯定有疑惑，并行度指的什么？我认为在spark中，这个并行度指的是partition的数量，无论是通过parallelize初始化rdd，还是通过join和reduceByKey等shuffle操作，都意味着需要确定这个新rdd的paritition数量。这里涉及到一个参数<code>spark.default.parallelism</code>，该参数<strong>大多数情况下</strong>是parallelize、join、reducdeByKey等操作的<strong>默认</strong>并行度。如果不定义这个参数，默认情况下分区数量在不同情景的情况下有所不同：</p>
<ul>
<li>对于join和reduceByKey等shuffle操作，分区数一般为多个父rdd中partition数目最大的一个。</li>
<li>对于parallelize进行初始化操作，分区数在不同部署模式下不同：<ul>
<li>local[*]：本地cpu的core数量，local[N]则为N，local则为1</li>
<li>meos：默认为8</li>
<li>other：一般为executor个数 * 每个executor的core个数</li>
</ul>
</li>
<li>当然如果定义了<code>spark.default.parallelism</code>参数，其默认分区数也不一定是其值，具体分析见<a href="/2019/12/22/Spark学习系列之二：rdd分区数量分析.html">Spark学习系列之二：rdd分区数量分析</a>。实际api中也能通过传递numPartitions参数覆盖<code>spark.default.parallelism</code>，自行决定并行度。</li>
<li>比如正在使用的mac是四核，假设向yarn申请executor个数为2，每个executor的core数量为1，那么spark.default.parallelism的值为2，这时一般情况下是不能充分利用其申请核数资源的，最好是申请核数的2~3倍。可以通过 –conf 传入参数 <code>--conf spark.default.parallelism = 4</code> 或者 <code>--conf spark.default.parallelism = 6</code>，使其默认值为申请核数的2~3倍。如果有的task执行比较快，core就空闲出来了，为了多利用core就设置task数量为2~3倍。当然最后的并行度还需要根据实际情况进行分析。</li>
</ul>
<blockquote>
<p>如何确定本机核数？通过local[*]模式进行parallelize初始化rdd，再输出myrdd.partitions.size即可得，也可以通过java代码Runtime.getRuntime.availableProcessors()获得</p>
</blockquote>
<p>参考：<br><a href="https://spark.apache.org/docs/latest/configuration.html" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/configuration.html</a><br><a href="http://spark.apache.org/docs/latest/tuning.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/tuning.html</a></p>
<h2 id="问题二：standalone模式下，executor个数和executor核数如何确定？"><a href="#问题二：standalone模式下，executor个数和executor核数如何确定？" class="headerlink" title="问题二：standalone模式下，executor个数和executor核数如何确定？"></a>问题二：standalone模式下，executor个数和executor核数如何确定？</h2><p>由于需要通过spark streaming读取kafka，如果对应topic的partition数量已知，那么应该启动对应个数的executor，因为kafka的一个parition同一时间只允许同一个groupid的consumer读取，如果topic的partition为1，申请的executor为2，那么将只有一个executor的资源得到了利用。</p>
<p>既然executor个数比较重要，yarn模式可以通过<code>--num-executors</code>确定executor个数，那standalone模式如何确定的呢？直接先说结论：</p>
<ul>
<li>executor的数量 = total-executor-cores/executor-cores</li>
<li><code>--total-executor-cores</code> 对应配置 <code>spark.cores.max</code> (default: <code>spark.deploy.defaultCores</code>)，表示一个application最大能用的core数目；如果没有设置则默认上限为<code>spark.deploy.defaultCores</code>，该配置的值默认为infinite（不限）</li>
<li><code>--executor-cores</code> 对应配置 <code>spark.executor.cores</code>，表示每个executor的core数目</li>
<li>可以看到standalone的executor数量并不能直接指定，而是通过core的换算得到的，如果对executor数目有要求的话，可以额外关注一下。</li>
</ul>
<blockquote>
<p>以下是我写demo过程遇到问题，以及解决问题的大致流程。</p>
</blockquote>
<p>在写demo过程中通过spark-sumbit提交任务时，忘了写master，但是通过<code>--executor-cores</code>指定了每个executor的core数量。等应用跑起来后，发现spark ui上，发现worker上有1个executor，每个executor4个core，这显然不符合的预期。明明通过<code>--executor-cores</code>指定了executor的core数量，为什么申请到的core数目不符合预期？即使spark-submit的script中没包含master，但是程序是指定了master（spark://zhangqilongdeMacBook-Air.local:7077）。我决定进行多次调整参数，验证每种情况下申请到executor数量和每个executor的core数量，总结如下：</p>
<ul>
<li>master和executor-cores，只配置一个或者两个都不配，则只申请一个executor，并且executor将尽量使用worker的所有core。</li>
<li>master和executor-cores两个都配，则申请的executor数量 = workder core的总数/executor-cores，每个executor的core数量和executor-cores一致。</li>
</ul>
<p>通过源码可以发现：</p>
<ul>
<li><code>--executor-cores</code>只有在–master为standalone、yarn、kubernetes模式下才会生效，如果不是这些模式，将会通过<strong>默认配置文件</strong>指定缺失的值。即如果不指定master的情况下（默认为local[*]），<code>--executor-cores</code>并不会生效，并且使用 <code>SPAKR_HOME/conf/spark-defaults.conf</code>配置文件中的值对其赋值，如果该配置文件中依然不存在，则为spark系统默认对该变量的值，即infinite（不限）。</li>
<li><code>--total-executor-cores</code>可以配置standalone每个application可以用的核总数（其实通过spark-submit命令行的提示也能看出来，因为yarn模式下该值不可配所以一开始这个配置被我忽略了）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">org.apache.spark.deploy.<span class="type">Submit</span></span><br><span class="line"></span><br><span class="line">...省略部分代码</span><br><span class="line">	<span class="comment">//可以看到spark.executor.cores只在某些情况下才会被赋值</span></span><br><span class="line">	<span class="type">OptionAssigner</span>(args.executorCores, <span class="type">STANDALONE</span> | <span class="type">YARN</span> | <span class="type">KUBERNETES</span>, <span class="type">ALL_DEPLOY_MODES</span>, confKey = <span class="string">"spark.executor.cores"</span>),</span><br><span class="line">	<span class="type">OptionAssigner</span>(args.totalExecutorCores, <span class="type">STANDALONE</span> | <span class="type">MESOS</span> | <span class="type">KUBERNETES</span>, <span class="type">ALL_DEPLOY_MODES</span>, confKey = <span class="string">"spark.cores.max"</span>)</span><br><span class="line"></span><br><span class="line">...省略部分代码</span><br><span class="line">    <span class="comment">// Load any properties specified through --conf and the default properties file</span></span><br><span class="line">    <span class="comment">// 通过sparkProperties（已经读取了spark-defaluts.conf内动）hashMap对缺失配置进行填充。</span></span><br><span class="line">    <span class="keyword">for</span> ((k, v) &lt;- args.sparkProperties) &#123;</span><br><span class="line">      sparkConf.setIfMissing(k, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...省略部分代码</span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="https://spark.apache.org/docs/latest/spark-standalone.html" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/spark-standalone.html</a></p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/12/16/Spark学习系列之一：新手常见问题.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2019/11/10/golang数据库连接broken-pipe异常原因分析及解决.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/10/golang数据库连接broken-pipe异常原因分析及解决.html" class="post-title-link" itemprop="url">golang数据库连接broken pipe异常原因分析及解决</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-10 21:57:03" itemprop="dateCreated datePublished" datetime="2019-11-10T21:57:03+08:00">2019-11-10</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-17 14:32:49" itemprop="dateModified" datetime="2020-05-17T14:32:49+08:00">2020-05-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>在golang开发中，在使用mysql数据库时一般使用数据库驱动包为 go-sql-driver/mysql，该包是按照go官方包database/sql定义规范实现的。我们线上的程序偶尔会在标准错误输出 “broken pip”，为了究其原因做了些调研，并给出了解决方法。</p>
</blockquote>
<h2 id="线上场景"><a href="#线上场景" class="headerlink" title="线上场景"></a>线上场景</h2><p>目前 <strong>项目A</strong> 使用的go-sql-driver/mysql版本为 <strong>3654d25ec346ee8ce71a68431025458d52a38ac0</strong> ， <strong>项目B</strong> 使用的版本为 <strong>v1.3.0</strong> ，其中 <strong>项目A</strong> 的版本低于v1.3.0。它们线上标准错误输出都有类似以下的日志，但是程序的业务逻辑却没有影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysql] 2019/08/01 17:12:18 packets.go:33: unexpected EOF</span><br><span class="line">[mysql] 2019/08/01 17:12:18 packets.go:130: write tcp 127.0.0.1:59722-&gt;127.0.0.1:3306: write: broken pipe</span><br></pre></td></tr></table></figure>
<p>通过日志输出以及堆栈可以找到 <code>go-sql-driver/mysql/packets.go</code> 对应的源码，可以发现第一条日志是以下第8行代码打印，第二条是第9行调用<code>mc.Close()</code>关闭连接时报错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read packet to buffer 'data'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *mysqlConn)</span> <span class="title">readPacket</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> prevData []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// read packet header</span></span><br><span class="line">        data, err := mc.buf.readNext(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            errLog.Print(err)</span><br><span class="line">            mc.Close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, driver.ErrBadConn</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><blockquote>
<p>通过网上搜索能够大概猜出是mysql server主动关闭的原因，我们可以通过设置mysql server主动关闭连接来复现线上场景，并且通过tcpdump观察其原因。</p>
</blockquote>
<h3 id="1-设置mysql-server主动关闭连接时间"><a href="#1-设置mysql-server主动关闭连接时间" class="headerlink" title="1.设置mysql server主动关闭连接时间"></a>1.设置mysql server主动关闭连接时间</h3><p>mysql server默认设置的关闭不活跃连接时间为28800秒（8小时），我们通过 <code>set global wait_time=10</code> 设置为10秒，便于问题重现。</p>
<h3 id="2-运行tcpdump和测试demo"><a href="#2-运行tcpdump和测试demo" class="headerlink" title="2.运行tcpdump和测试demo"></a>2.运行tcpdump和测试demo</h3><p>1.通过tcpdump可以收集tcp数据包的发送接收情况，尤其是的在mysql server关闭连接后，go程序如何和mysql server交互是我们关注的重点，tcpdump命令如下：</p>
<p><code>sudo tcpdump -s 0 -t -i lo -l port 3306 -w lo.cap</code></p>
<p>2.运行一个简单的测试demo</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// before you run this test program, please run the script in your mysql</span></span><br><span class="line">    <span class="comment">// "set global wait_timeout=10;"</span></span><br><span class="line">    <span class="comment">// 表示mysql server关闭不活跃连接的等待时间</span></span><br><span class="line">    <span class="comment">// 参考 https://github.com/go-sql-driver/mysql/issues/657</span></span><br><span class="line">    db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:zhang@tcp(127.0.0.1:3306)/?charset=latin1&amp;autocommit=1&amp;parseTime=true&amp;loc=Local&amp;timeout=3s"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line">    <span class="comment">//db.SetConnMaxLifetime(5 * time.Second)</span></span><br><span class="line">    err = db.Ping()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            _, err := db.Exec(<span class="string">"select * from test_time.A"</span>)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Wait for 11 seconds. This should be enough to timeout the conn, since `wait_timeout` is 10s</span></span><br><span class="line">            time.Sleep(<span class="number">11</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">1000</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/11/10/golang数据库连接broken-pipe异常原因分析及解决.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2019/11/09/浅谈golang对mysql时间类型数据转换的问题.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/09/浅谈golang对mysql时间类型数据转换的问题.html" class="post-title-link" itemprop="url">浅谈golang对mysql时间类型数据转换的问题</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-09 22:19:22" itemprop="dateCreated datePublished" datetime="2019-11-09T22:19:22+08:00">2019-11-09</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-17 14:32:49" itemprop="dateModified" datetime="2020-05-17T14:32:49+08:00">2020-05-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>部门某些业务需要在海外上线，涉及到数据库时区、应用时区的转换。本文将讨论golang针对数据库时区的处理问题。</p>
<blockquote>
<p>为了方便讨论，避免混淆，本文对“时间”的表达方式作出约定：时间=时区时间+时区。如时间 2019-05-21 15:48:38 CST ,则其时区时间为2019-05-21 15:48:38，时区为CST。如果没有特别说明，本文提到的“时间”都包含时区。</p>
</blockquote>
<h2 id="一、golang中mysql数据库驱动的时区配置"><a href="#一、golang中mysql数据库驱动的时区配置" class="headerlink" title="一、golang中mysql数据库驱动的时区配置"></a>一、golang中mysql数据库驱动的时区配置</h2><p>mysql中关于时间日期的概念数据模型有<code>DATE</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>，golang程序根据数据链接DSN（Data Source Name）配置，数据库驱动 github.com/go-sql-driver/mysql 可以对这三种类型的值转换成go中的time.Time类型，关键配置如下：</p>
<ul>
<li>parseTime<ul>
<li>默认为false，把mysql中的 <code>DATE</code>、<code>DATETIME</code>、<code>TIMESTAMP</code> 转为golang中的[]byte类型</li>
<li>设置为true，将会转为golang中的 <code>time.Time</code> 类型</li>
</ul>
</li>
<li>loc<ul>
<li>默认为UTC，表示转换<code>DATE</code>、<code>DATETIME</code>、<code>TIMESTAMP</code> 为 <code>time.Time</code> 时所使用的时区</li>
<li>设置成Local，则与系统设置的时区一致</li>
<li>如果想要设置成中国时区可以设置成 <code>Asia/Shanghai</code> ，更多的时区可以参考 <code>/usr/share/zoneinfo/</code> 或者<code>$GOROOT/lib/time/zoneinfo.zip</code>。</li>
</ul>
</li>
</ul>
<p>在实际的使用中，我们往往会配置成 <code>parseTime=true</code> 和 <code>loc=Local</code>，这样避免了手动转换<code>DATE</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>。</p>
<h2 id="二、golang如何转换mysql的时间类型"><a href="#二、golang如何转换mysql的时间类型" class="headerlink" title="二、golang如何转换mysql的时间类型"></a>二、golang如何转换mysql的时间类型</h2><blockquote>
<p>在涉及到不同时区时，我们golang程序应该怎么处理mysql的 DATE、DATETIME、TIMESTAMP 数据类型？是否只要配置了parseTime=true&amp;loc=xxx就不会有问题？我们来做两个小实验。</p>
</blockquote>
<h3 id="实验一：应用和数据库在同一时区"><a href="#实验一：应用和数据库在同一时区" class="headerlink" title="实验一：应用和数据库在同一时区"></a>实验一：应用和数据库在同一时区</h3><h4 id="1-timestamp"><a href="#1-timestamp" class="headerlink" title="1.timestamp"></a>1.timestamp</h4><p>a.系统时区设置为CST，mysql和golang在同一个时区的机器上。（如何设置和查看时区可以参考本文第五节内容。）</p>
<ul>
<li>golang在程序中连接数据库使用的配置DSN是parseTime=true&amp;loc=xxx，xxx分别为UTC、Asia/Shanghai、Europe/London、Local。</li>
<li>mysql终端中insert一条timestamp【时区时间】为2019-04-02 13:18:17的记录，其UNIX_TIMESTAMP(timestamp)=1554182297。</li>
</ul>
<p>以下1~5行均为golang程序读取刚插入数据库的数据结果，第一列输出分别为链接数据库DSN配置，第二列为转换为time.Time后的输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parseTime=true&amp;loc=UTC:                  2019-04-02 13:18:17 +0000 UTC</span><br><span class="line">parseTime=true&amp;loc=Asia/Shanghai:        2019-04-02 13:18:17 +0800 CST</span><br><span class="line">parseTime=true&amp;loc=Europe/London:        2019-04-02 13:18:17 +0100 BST</span><br><span class="line">parseTime=true&amp;loc=Local:                2019-04-02 13:18:17 +0800 CST</span><br></pre></td></tr></table></figure>
<p>b.同样的机器，修改系统时区为BST，在mysql终端中select上一步插入的数据，timestamp【时区时间】为2019-04-02 06:18:17，UNIX_TIMESTAMP(timestamp)=1554182297。程序输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parseTime=true&amp;loc=UTC:                  2019-04-02 06:18:17 +0000 UTC</span><br><span class="line">parseTime=true&amp;loc=Asia/Shanghai:        2019-04-02 06:18:17 +0800 CST</span><br><span class="line">parseTime=true&amp;loc=Europe/London:        2019-04-02 06:18:17 +0100 BST</span><br><span class="line">parseTime=true&amp;loc=Local:                2019-04-02 06:18:17 +0100 BST</span><br></pre></td></tr></table></figure>
<p>c.小结：</p>
<ul>
<li>UNIX_TIMESTAMP可以把mysql的timstamp转为距离 1970-01-01 00:00:00 UTC 的秒数，这个经过转换后的值无论mysql在任何时区都不会变。</li>
<li>即使同一条数据库记录，由于时区不同，mysql终端中直接select出的timestamp的【时区时间】也不同。也侧面说明了mysql内部实现的timstamp结构体中包含了时区信息，在输出时根据当前时区做转换，输出当前【时区时间】。</li>
<li>golang程序获取到的time.Time等于：mysql【时区时间】+ 时区，时区为loc指定的时区，与mysql时区没有关系。</li>
</ul>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/11/09/浅谈golang对mysql时间类型数据转换的问题.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2018/11/14/effective-go-learning-2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/14/effective-go-learning-2.html" class="post-title-link" itemprop="url">effective go learning 2</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-14 01:10:09" itemprop="dateCreated datePublished" datetime="2018-11-14T01:10:09+08:00">2018-11-14</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-17 14:32:49" itemprop="dateModified" datetime="2020-05-17T14:32:49+08:00">2020-05-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>从Two-dimensional slices开始，使用中文版的effctive_go学习<br><a href="https://www.kancloud.cn/kancloud/effective/72207" target="_blank" rel="noopener">https://www.kancloud.cn/kancloud/effective/72207</a></p>
<h2 id="Data："><a href="#Data：" class="headerlink" title="Data："></a>Data：</h2><h3 id="二维切片"><a href="#二维切片" class="headerlink" title="二维切片:"></a>二维切片:</h3><ul>
<li>Go的数组和切片都是一维的。要创建等价的二维数组或者切片，需要定义一个数组的数组或者切片的切片。</li>
</ul>
<h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps:"></a>Maps:</h3><ul>
<li>Map是一种方便，强大的内建数据结构，其将一个类型的值（key）与另一个类型的值（element或value） 关联一起。</li>
<li>key可以为任何 <strong>定义了等于操作符</strong> 的类型，例如整数，浮点和复数，字符串，指针，接口（只要其动态类型支持等于操作），结构体和数组。</li>
<li><strong>切片不能 作为map的key，因为它们没有定义等于操作</strong>。和切片类似，<strong>map持有对底层数据结构的引用。如果将map传递给函数，其对map的内容做了改变，则这些改变对于调用者是可见的</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">attended := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;</span><br><span class="line">    <span class="string">"Ann"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"Joe"</span>: <span class="literal">true</span>,</span><br><span class="line">    ...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> attended[person] &#123; <span class="comment">// will be false if person is not in the map</span></span><br><span class="line">    fmt.Println(person, <span class="string">"was at the meeting"</span>)&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果只测试是否在map中存在，而不关心实际的值，你可以将通常使用变量的地方换成空白标识符（_）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, present := timeZone[tz]</span><br></pre></td></tr></table></figure>
<ul>
<li>要删除一个map项，使用delete内建函数，其参数为map和要删除的key。即使key已经不在map中，这样做也是安全的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(timeZone, <span class="string">"PDT"</span>)  <span class="comment">// Now on Standard Time</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>map不太好判断是否存在某个key，如果key不存在返回的对应类型的零值，如果已有key的value恰好为零值会导致误判</strong></li>
</ul>
<h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><ul>
<li>Go中的格式化打印使用了与C中printf家族类似的风格，不过更加丰富和通用。这些函数位于fmt程序包中，并具有大写的名字：fmt.Printf，fmt.Fprintf，fmt.Sprintf等等。字符串函数（Sprintf等）返回一个字符串，而不是填充到提供的缓冲里。</li>
<li>你不需要提供一个格式串。对每个Printf，Fprintf和Sprintf，都有另外一对相应的函数，例如Print和Println。这些函数不接受格式串，而是为每个参数生成一个缺省的格式。Println版本还会在参数之间插入一个空格，并添加一个换行，而Print版本只有当两边的操作数都不是字符串的时候才增加一个空格。在这个例子中，每一行都会产生相同的输出。</li>
<li>格式化打印函数fmt.Fprint等，接受的第一个参数为任何一个实现了io.Writer接口的对象；变量os.Stdout和os.Stderr是常见的实例。</li>
<li>如果只是想要缺省的转换，像十进制整数，你可以使用 <strong>通用格式%v（代表“value”）</strong>；这正是Print和Println所产生的结果。而且，这个格式可以打印任意的的值，甚至是数组，切片，结构体和map。</li>
<li>当打印一个结构体时，带修饰的格式 <strong>%+v会将结构体的域使用它们的名字进行注解</strong>，对于任意的值，格式%#v会按照完整的Go语法打印出该值。</li>
<li>还可以通过 <strong>%q</strong> 来实现带引号的字符串格式，用于类型为 <strong>string或[]byte</strong> 的值。格式 <strong>%#q</strong> 将尽可能的使用反引号。（格式%q还用于整数和符文，产生一个带单引号的符文常量。）</li>
<li><strong>%x</strong> 用于字符串，字节数组和字节切片，以及整数，生成一个 <strong>长的十六进制字符串</strong>，并且如果在格式中 <strong>有一个空格（% x）</strong>，其将会在 <strong>字节中插入空格</strong>。</li>
<li>不要在Sprintf里面调用接收者的String方法，否则会造成无穷递归，如下。只有%s匹配才会调用MyString的String方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyString)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"MyString=%s"</span>, m) <span class="comment">// Error: will recur forever.</span></span><br><span class="line"><span class="comment">//    return fmt.Sprintf("MyString=%s", string(m)) // OK: note conversion.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>另一种打印技术，是将一个打印程序的参数直接传递给另一个这样的程序。Printf的签名使用了类型…interface{}作为最后一个参数，来指定在格式之后可以出现任意数目的（任意类型的）参数。</li>
</ul>
<h3 id="append内建函数"><a href="#append内建函数" class="headerlink" title="append内建函数:"></a>append内建函数:</h3><ul>
<li>其中T为任意给定类型的占位符。你在Go中是无法写出一个类型T由调用者来确定的函数。这就是为什么append是内建的：它需要编译器的支持。append所做的事情是将元素添加到切片的结尾，并返回结果。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []T, elements ...T)</span> []<span class="title">T</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">x</span> := []<span class="title">int</span></span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果想要在append中把一个slice添加到另一个slice要怎么做？在调用点使用 “…”，</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">y := []<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, y...)</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看出 “…” 的作用是，把一个slice转为对应的type，作为一个参数列表进行传递</li>
</ul>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/11/14/effective-go-learning-2.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Long</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/salmon7" title="GitHub &rarr; https://github.com/salmon7" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:qilong_zhang@163.com" title="E-Mail &rarr; mailto:qilong_zhang@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Long</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
      
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
