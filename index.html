<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="keep running">
<meta property="og:url" content="http://blog.zhang7long.com/index.html">
<meta property="og:site_name" content="keep running">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="keep running">





  
  
  <link rel="canonical" href="http://blog.zhang7long.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>keep running</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c81c2d859c047c5b20dc74f1bd5eb198";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">keep running</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2020/08/16/es学习系列之二：Aggregation-collect-mode-and-execution-hint-md.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/08/16/es学习系列之二：Aggregation-collect-mode-and-execution-hint-md.html" class="post-title-link" itemprop="url">es学习系列之二：Aggregation collect mode and execution hint.md</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-08-16 15:37:32 / Modified: 22:20:35" itemprop="dateCreated datePublished" datetime="2020-08-16T15:37:32+08:00">2020-08-16</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>如无特别说明，本文讨论的内容均基于 es 7.*</p>
</blockquote>
<h2 id="Term-Aggregation的深度优先以及广度优先"><a href="#Term-Aggregation的深度优先以及广度优先" class="headerlink" title="Term Aggregation的深度优先以及广度优先"></a>Term Aggregation的深度优先以及广度优先</h2><p>Term aggregation 是我们常用的聚合查询，对于有 <strong>父子聚合</strong> 的场景下，理解其执行父聚合以及子聚合的时机对我们优化聚合查询有很大的帮助，collect mode就指定了它们的执行时机，共有两种模式，一种是depth first，另一种是breadth first。</p>
<h3 id="depth-first"><a href="#depth-first" class="headerlink" title="depth first"></a>depth first</h3><p>一般来说，depth first适合大多数场景，因为大多数情况下需要聚合的字段不会是大量的唯一值。</p>
<ul>
<li>聚合过程<ul>
<li>1.先计算出一个桶，然后再根据这个桶计算出子聚合的结果，构建出一棵聚合树。然后不断重复前面的过程，直到所有的桶计算完毕。</li>
<li>2.对步骤一计算出的结果进行排序，也就是对各个聚合树进行排序。</li>
<li>3.根据过滤条件和 size 等参数修剪结果。</li>
</ul>
</li>
<li>适合场景<ul>
<li>大多数term都是重复的</li>
<li>要求返回的aggs size比较大</li>
<li>原因：不需要缓存父聚合的doc_id，直接聚合成一棵棵聚合树，每棵聚合树的每个节点数据结构为(value, doc_count)，并且大多数的聚合树不会被修剪</li>
</ul>
</li>
<li>聚合计算下，多层聚合会让一个文档与其他文档产生关联，也就是说会形成一棵棵聚合树。深度优先就是先计算获得所有的聚合树，然后再进行后续处理。</li>
</ul>
<h3 id="breadth-first"><a href="#breadth-first" class="headerlink" title="breadth first"></a>breadth first</h3><ul>
<li>聚合过程<ul>
<li>1.先计算出第一层聚合的结果。</li>
<li>2.根据步骤一得出的结果进行排序。</li>
<li>3.根据过滤条件和 size 等参数修整第一层节点。</li>
<li>4.根据各个节点进行后续的子聚合计算。</li>
</ul>
</li>
<li>适合场景<ul>
<li>大多数term都是唯一的</li>
<li>要求返回的aggs size 比较小</li>
<li>原因：缓存父聚合的doc_id，聚合树第一层节点，即根节点，的数据结构为(value, doc_count, set(doc_id))，为了保证使用的缓存尽量小，则 avg(doc_count_per_bucket) * size(buckets) 尽量小</li>
</ul>
</li>
<li>对于基数大于请求的大小的字段或基数未知的字段（例如，数字字段或脚本），默认值为breadth_first</li>
<li>当使用breadth_first模式时，属于最上层存储桶的文档集将被缓存以供后续重播，因此这样做会产生内存开销，该开销与匹配文档的数量成线性关系。</li>
<li>使用广度优先设置时，仍可以使用order参数来引用子聚合中的数据。父级聚合知道需要先调用此子级聚合，然后再调用其他任何子级聚合。<ul>
<li>这里的主要意思是，如果父聚合的排序时候使用的是子聚合的结果，则会在执行父聚合前先执行该子聚合。</li>
</ul>
</li>
</ul>
<h3 id="depth-first-vs-breadth-first"><a href="#depth-first-vs-breadth-first" class="headerlink" title="depth first vs. breadth first"></a>depth first vs. breadth first</h3><ul>
<li>关键点：<ul>
<li>父子聚合的组合数的多少 + 返回buckets数量大小（分别对应计算的难度+使用率）<ul>
<li>父聚合字段的基数大，父子聚合的组合数多，需要返回的buckets数量小，适合广度优先</li>
<li>父聚合字段的基数小，父子聚合的组合数少，需要返回的buckets数量大，适合深度优先</li>
</ul>
</li>
<li>比如：<ul>
<li>父聚合字段有10000，父子聚合的组合数约为 100000，需要返回buckets为5，则可能适合广度优先</li>
<li>父聚合字段有10，父子聚合的组合数约为 100，需要返回buckets为100，则可能适合深度优先</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Term-Aggregation的Execution-hint"><a href="#Term-Aggregation的Execution-hint" class="headerlink" title="Term Aggregation的Execution hint"></a>Term Aggregation的Execution hint</h2><h3 id="global-ordinals"><a href="#global-ordinals" class="headerlink" title="global_ordinals"></a>global_ordinals</h3><p>我们知道doc values存储的时候，会对应original value分配一个ordinal以减小磁盘的使用，也减小聚合过程中内存的使用。</p>
<ul>
<li>聚合过程<ul>
<li>segment级别的聚合：<ul>
<li>在聚合字段的doc values数据结构中，完成 (doc_id, ordinal) -&gt; (ordinal, set(doc_id)) 的聚合计算</li>
</ul>
</li>
<li>shard级别的聚合：<ul>
<li>在shard内部多个segment之上构建 global ordinla map，其数据结构为 (segment_id, ordinal, global ordinal)，当ordinal对应的初始值相同时，其对应的global ordinal也相同。</li>
<li>根据 global ordinla map，完成 (ordinal, set(doc_id)) -&gt; (global ordinal, set(doc_id) 的转换。</li>
<li>根据 global ordinal 进行分桶，并根据doc count进行排序，选出前n个桶，完成 (global ordinal, set(doc_id) -&gt;  (global ordinal, doc count) 的聚合计算。</li>
<li>根据 global ordinal map以及segment的doc values，把global ordinal替换成原始值，完成 (global ordinal, doc count) -&gt; (segment_id, ordinal, doc count) -&gt; (original value, doc count) 的转换。</li>
</ul>
</li>
<li>index级别的聚合：<ul>
<li>在协调节点完成全局前n个结果的聚合。</li>
</ul>
</li>
</ul>
</li>
<li>global ordinals 的有效性<ul>
<li>因为global ordinals为shard上的所有segment提供了统一的map，所以当新的segment变为可见时（常见为refresh的时候），还需要完全重建它们。所以，global ordinals 更加适用于 <strong>历史数据</strong>。</li>
</ul>
</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>相对而言map更加简单，主要的不同点在于shard级别聚合的时候不再构建global ordinal map，而是直接返回original value到shard</p>
<ul>
<li>聚合过程<ul>
<li>segment级别的聚合：<ul>
<li>在聚合字段的doc values数据结构中，完成 (doc_id, ordinal) -&gt; (ordinal, set(doc_id)) 的聚合计算</li>
<li>把ordinal替换成初始值，完成 (ordinal, set(doc_id)) -&gt; (original, set(doc_id)) 的转换</li>
</ul>
</li>
<li>shard级别的聚合：<ul>
<li>根据 original value进行分桶，并根据doc count进行排序，选出前n个桶，完成 (original, set(doc_id) -&gt; (original, doc count) 的聚合计算。</li>
</ul>
</li>
<li>index级别的聚合：<ul>
<li>在协调节点完成全局前n个结果的聚合。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="global-ordinals-vs-map"><a href="#global-ordinals-vs-map" class="headerlink" title="global_ordinals vs. map"></a>global_ordinals vs. map</h3><ul>
<li>适合global_ordinals模式<ul>
<li>聚合字段基数不大</li>
<li>refresh 间隔比较大</li>
<li>不再写入的索引，比如历史索引</li>
<li>开启 eager_global_ordinals 配置，在写入索引时就构建global ordinals map。但是可能会对写入索引的速度有影响</li>
</ul>
</li>
<li>适合map模式<ul>
<li>聚合字段基数很大</li>
<li>需要注意可能会引起更大的内存消耗量</li>
</ul>
</li>
</ul>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2020/08/16/es学习系列之二：Aggregation-collect-mode-and-execution-hint-md.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2020/08/08/python2中format和百分号拼接字符串的异同.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/08/08/python2中format和百分号拼接字符串的异同.html" class="post-title-link" itemprop="url">python2中format和%拼接字符串的异同</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-08-08 15:25:55 / Modified: 17:01:57" itemprop="dateCreated datePublished" datetime="2020-08-08T15:25:55+08:00">2020-08-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>相信python2的编码问题大多数开发同学都遇到过，在出现非 ascii 编码字符时，就很容易编码异常的问题。python2的字符编码分为 str 以及 unicode，具体情况这里不再敖述，只会总结字符串拼接时应该注意的问题以及可能遇到的坑点。</p>
<p>以下几点常识是下面进一步讨论问题的基础：</p>
<ul>
<li>str转为unicode的过程，称为解码，即 decode。</li>
<li>unicode转为str，称为编码，即 encode。</li>
<li>使用<code>%</code>把str和unicode拼接，会自动隐式地把str转为unicode后，再进行拼接。（如果是fomat拼接呢？这里留个悬念，答案稍后揭晓）</li>
<li>当导入<strong>future</strong>包的unicode_literals特性时，python定义的字符都是unicode，而不是默认的str。这个也是为了让python2能够导入python3的特性，因为在python3中的str都是unicode。</li>
</ul>
<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="% 拼接字符串"></a><code>%</code> 拼接字符串</h3><p>我们首先看看pyhon2中的使用<code>%</code>字符串拼接情况。从第一组结果来看，我们可以看到只要格式化串和字符串参数其中一个为unicode，最终结果就为unicode，这个和上面讲的第三点一致。在对str和unicode拼接的时候，会自动把str转为unicode，如第二组的中间两个结果。</p>
<p>但是我们需要注意编码的问题，如第2个结果，由于”中文”是非 acsii 编码，而且python解释器不知道其类型，会用ascii编码对其进行解码，相当于 <code>u&quot;%s&quot; % (&quot;中文&quot;).decode(&quot;ascii&quot;)</code>，而ascii不认识非 0~127 编码所以就报错，当然我们可以手动指定用”utf-8”进行解码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">"%s"</span> % (<span class="string">"hello"</span>))</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">u"%s"</span> % (<span class="string">"hello"</span>))</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">"%s"</span> % (<span class="string">u"hello"</span>))</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">u"%s"</span> % (<span class="string">u"hello"</span>))</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">"%s"</span> % (<span class="string">"中文"</span>))</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">u"%s"</span> % (<span class="string">"中文"</span>))         <span class="comment"># 最终结果为unicode，会隐式地通过ascii编码把"中文"解码为unicode</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: <span class="string">'ascii'</span> codec can<span class="string">'t decode byte 0xe4 in position 0: ordinal not in range(128)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; type(u"%s" % ("中文".decode("utf-8")))</span></span><br><span class="line"><span class="string">&lt;type '</span>unicode<span class="string">'&gt;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; type("%s" % (u"中文"))</span></span><br><span class="line"><span class="string">&lt;type '</span>unicode<span class="string">'&gt;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; type(u"%s" % (u"中文"))</span></span><br><span class="line"><span class="string">&lt;type '</span>unicode<span class="string">'&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="format-拼接字符串"><a href="#format-拼接字符串" class="headerlink" title="format 拼接字符串"></a><code>format</code> 拼接字符串</h3><p>同样的，我们先看下面的第一组结果，是不是有点吃惊？第一组的第二结果不是unicode类型，而是str类型，这个跟<code>%</code>是不同的。很显然从结果上看，我们知道对于<code>format</code>其拼接结果类型取决于其格式化串的类型，而与参数没有任何关系。</p>
<p>理解的第一组数据的规律后，再看第二组就知道为什么有的情况会报异常了。第二组的第二个结果，由于最终结果为str，pyhton解释器会默认用 ascii 对 <code>u&quot;中文&quot;</code> 进行编码，而第三个结果，由于最终结果为unicode，python解释器会默认用 ascii 对应 “中文” 进行解码，而报错的理由和前面的情况一致，都是因为ascii不认识非 0~127 编码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">"&#123;&#125;"</span>.format(<span class="string">"hello"</span>))</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">"&#123;&#125;"</span>.format(<span class="string">u"hello"</span>))</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">u"&#123;&#125;"</span>.format(<span class="string">"hello"</span>))</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">u"&#123;&#125;"</span>.format(<span class="string">u"hello"</span>))</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">"&#123;&#125;"</span>.format(<span class="string">"中文"</span>))</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">"&#123;&#125;"</span>.format(<span class="string">u"中文"</span>))         <span class="comment"># 最终结果为str，会隐式地通过ascii编码把u"中文"编码为ascii</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can<span class="string">'t encode characters in position 0-1: ordinal not in range(128)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; type("&#123;&#125;".format(u"中文".encode("utf-8")))</span></span><br><span class="line"><span class="string">&lt;type '</span>st<span class="string">r'&gt;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; type(u"&#123;&#125;".format("中文"))          # 最终结果为unicode，会隐式地通过ascii编码把"中文"解码为unicdoe</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">UnicodeDecodeError: '</span>ascii<span class="string">' codec can'</span>t decode byte <span class="number">0xe4</span> <span class="keyword">in</span> position <span class="number">0</span>: ordinal <span class="keyword">not</span> <span class="keyword">in</span> range(<span class="number">128</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">u"&#123;&#125;"</span>.format(<span class="string">"中文"</span>.decode(<span class="string">"utf-8"</span>)))</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="string">u"&#123;&#125;"</span>.format(<span class="string">u"中文"</span>))</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><p>而我们线上的问题，要比以上两种都要隐蔽，大致如下：</p>
<h4 id="代码目录结构"><a href="#代码目录结构" class="headerlink" title="代码目录结构"></a>代码目录结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> tree -L 2 -I &quot;*.pyc&quot;</span><br><span class="line">.</span><br><span class="line">├── test_module_002</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── __pycache__</span><br><span class="line">│   ├── main.py</span><br><span class="line">│   └── module_a.py</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2020/08/08/python2中format和百分号拼接字符串的异同.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2020/07/12/flink学习系列之一: taskmanager, slot与parallelism.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/07/12/flink学习系列之一: taskmanager, slot与parallelism.html" class="post-title-link" itemprop="url">flink学习系列之一: taskmanager, slot与parallelism</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-07-12 22:15:43 / Modified: 23:08:59" itemprop="dateCreated datePublished" datetime="2020-07-12T22:15:43+08:00">2020-07-12</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>如无特别说明，本文讨论的内容均基于 flink 1.7.1</p>
</blockquote>
<blockquote>
<p>最近一段时间用 flink 写一些 etl 作业，做数据的收集清洗入库，也遇到一些性能问题需要进一步解决，于是计划学习部分flink底层知识。第一篇，跟以前学习spark一样，从flink的并行度说起。</p>
</blockquote>
<h2 id="flink作业的启动模式"><a href="#flink作业的启动模式" class="headerlink" title="flink作业的启动模式"></a>flink作业的启动模式</h2><p>通过 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.7/ops/deployment/yarn_setup.html" target="_blank" rel="noopener">flink YARN Setup</a> 文档我们能够了解到，flink的启动方式大致有两种，<br>一种是先分配jobmanager、taskmanager的资源，等待后续提交作业，另一种是在提交的时候申请资源并运行。下面将简单介绍一下这两种启动方式的区别，并着重关注其并行度的计算，最后和spark并行度的计算对对比。</p>
<h3 id="部署方式一：在yarn中启动一个flink-session，提交job到该session"><a href="#部署方式一：在yarn中启动一个flink-session，提交job到该session" class="headerlink" title="部署方式一：在yarn中启动一个flink session，提交job到该session"></a>部署方式一：在yarn中启动一个flink session，提交job到该session</h3><ul>
<li>启动flink session<ul>
<li>./bin/yarn-session.sh -tm 8192 -s 32</li>
<li>关键配置：<ul>
<li>-n，指定 container 数量（即taskmanager的数量，不过已经不建议使用，对应的<a href="https://github.com/apache/flink/blob/release-1.7.1/flink-yarn/src/main/java/org/apache/flink/yarn/cli/FlinkYarnSessionCli.java#L373" target="_blank" rel="noopener">源码</a> </li>
<li>-tm，分配 taskmanager 内存大小</li>
<li>-jm，分配 jobmanager 内存大小</li>
<li>-s，每个taskmanager分配slot个数（如果配置了将会覆盖yarn的 parallelism.default 配置，parallelism.default 值默认为1）</li>
<li>-Dyarn.containers.vcores，在yarn中分配的vcore个数，默认和slot个数一致，即一个slot一个vcore</li>
<li>默认 taskmanager 的数量为1，并行度为 slot * taskmanager ，<a href="https://github.com/apache/flink/blob/release-1.7.1/flink-yarn/src/main/java/org/apache/flink/yarn/cli/FlinkYarnSessionCli.java#L619" target="_blank" rel="noopener">源码</a></li>
</ul>
</li>
<li>一旦 flink session在yarn中启动成功，将会展示有关 jobmanager 连接的详细信息，通过CTRL+C 或者 在client中输入stop关闭 flink session</li>
</ul>
</li>
<li>提交job到该session<ul>
<li>./bin/flink run ./examples/batch/WordCount.jar </li>
<li>关键配置：<ul>
<li>-c，指定入口class</li>
<li>-m，指定jobmanager地址</li>
<li>-p，指定作业的并行度</li>
</ul>
</li>
<li>client能够自动识别对应的 jobmanager 地址</li>
<li>并行度的确定：<ul>
<li>如果不指定 -p ，则作业并行度为 1 （parallelism.default 的配置值，默认为1）</li>
<li>如果指定-p，则作业则在该session下，以 -p 指定值的并行度运行。如果作业的并行度大于session的并行度，则会报异常，作业启动失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="部署方式二：在yarn中启动一个单独的作业"><a href="#部署方式二：在yarn中启动一个单独的作业" class="headerlink" title="部署方式二：在yarn中启动一个单独的作业"></a>部署方式二：在yarn中启动一个单独的作业</h3><ul>
<li>./bin/flink run -m yarn-cluster ./examples/batch/WordCount.jar</li>
<li>flink session的配置同样适用于启动单独的作业，需要加前缀 y 或者 yarn</li>
<li>关键配置：<ul>
<li>-n ，允许加载savepoint失败时启动程序</li>
<li>-d，client非阻塞模式启动作业</li>
<li>-p，指定作业并行度</li>
<li>-ytm，分配 taskmanager 内存大小</li>
<li>-yjm，分配 jobmanager 内存大小</li>
<li>-ys，指定每个taskmanager分配slot个数</li>
<li>-yn，指定container数量，和taskmanager数量一致</li>
</ul>
</li>
<li>并行度的确定<ul>
<li>如果指定了-m yarn-cluster，并且是 -d 或者 -yd 模式，不通过 -yid 指定 applicationid，则其并行度由 -p 决定。</li>
<li>flink会启动多少个taskmanager？我们知道flink作业的实际并行度是由 taskmanager * slot 决定的，默认情况下每个taskmanager的slot数量为1，所以yarn最终为了实现并行度为 -p 的作业，需要启动p个taskmanager。num( taskmanenger ) = p / slot </li>
</ul>
</li>
</ul>
<h2 id="spark-on-yarn-vs-flink-on-yarn"><a href="#spark-on-yarn-vs-flink-on-yarn" class="headerlink" title="spark on yarn vs. flink on yarn"></a>spark on yarn vs. flink on yarn</h2><blockquote>
<p>spark相关的executor以及并行的计算见 Spark学习系列之一和之二</p>
</blockquote>
<ul>
<li>executor vs. taskmanager<ul>
<li>spark submit 通过 –num-executors 控制executor数量</li>
<li>flink run 通过 -p 和 -ys 控制taskmanager数量</li>
</ul>
</li>
</ul>
<blockquote>
<p>另外spark on standalone模式下，其executor数量的计算方式和flink run差不多，它也是通过总的核数和每个executor核数反算所需的executor数目，可以把 total-executor-cores 类比 -p，executor-cores 类比 -ys）</p>
</blockquote>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2020/07/12/flink学习系列之一: taskmanager, slot与parallelism.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2020/05/17/es学习系列之一：Rollover-Index-VS-Index-Lifecycle-Management.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/05/17/es学习系列之一：Rollover-Index-VS-Index-Lifecycle-Management.html" class="post-title-link" itemprop="url">es学习系列之一：Rollover Index VS. Index Lifecycle Management</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-05-17 16:40:19" itemprop="dateCreated datePublished" datetime="2020-05-17T16:40:19+08:00">2020-05-17</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-08-08 15:17:48" itemprop="dateModified" datetime="2020-08-08T15:17:48+08:00">2020-08-08</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>如无特别说明，本文讨论的内容均基于 es 7.*</p>
</blockquote>
<h2 id="es的Rollover索引"><a href="#es的Rollover索引" class="headerlink" title="es的Rollover索引"></a>es的Rollover索引</h2><p>es的Rollover索引通常指的是一个别名指向某个索引，并且能够在索引的某些条件下进行轮转，如索引的创建时间长短、大小、文档数量。</p>
<p>如创建一个名为 nginx_log-000001 的索引，并指定其alias为nginx_log_write，并且我们对nginx_log_write写入3个文档（其实也是对nginx_log-000001写）。然后对别名调用rollover接口，<br>由于已经达到文档数目为3的条件，则会自动生成 nginx_log-000002 的索引。这时对nginx_log_write写入会自动写入到nginx_log-000002索引中。</p>
<p>需要注意的是，由于对索引设置alias的时候，没有添加 <code>&quot;is_write_index&quot;: true</code> 配置，则在执行rollover并创建新索引成功后，将会只指向<strong>一个</strong>索引（新索引），对nginx_log_write查询只能查到最新索引的数据，而不能查到历史数据。相反，如果配置了<code>&quot;is_write_index&quot;: true</code>，在rollover后alias会<strong>同时</strong>指向多个索引，并且最新索引设置为<code>&quot;is_write_index&quot;: true</code>，旧索引设置为<code>&quot;is_write_index&quot;: false</code>，对alias的<br>写入就是对最新索引的写入，查询时是对所有索引进行<strong>查询</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># 创建索引nginx_log-000001，并设置其别名为nginx_log_write</span><br><span class="line">PUT /nginx_log-000001</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aliases&quot;: &#123;</span><br><span class="line">    &quot;nginx_log_write&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 对别名写入文档，重复执行3次</span><br><span class="line">POST nginx_log_write/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;log&quot;:&quot;something before rollover&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 对别名执行rollover</span><br><span class="line">POST /nginx_log_write/_rollover</span><br><span class="line">&#123;</span><br><span class="line">  &quot;conditions&quot;: &#123;</span><br><span class="line">    &quot;max_age&quot;:   &quot;1d&quot;,</span><br><span class="line">    &quot;max_docs&quot;:  3,</span><br><span class="line">    &quot;max_size&quot;:  &quot;5gb&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 对新索引插入新数据</span><br><span class="line">POST nginx_log_write/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;log&quot;:&quot;something after rollover&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 分别查 nginx_log-000001、nginx_log-000002、nginx_log_write，对ginx_log_write只能查到最新索引的数据</span><br><span class="line">POST nginx_log_write/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 对非 &quot;is_write_index&quot;: true 模式的索引，可用 index_name-* 查询所有数据</span><br><span class="line">POST nginx_log-*/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，我们可以利用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/date-math-index-names.html" target="_blank" rel="noopener">Date Math</a> 创建带日期的rollover索引，更加方便索引管理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># PUT /&lt;nginx_log-&#123;now/d&#125;-000001&gt;，将创建名为 nginx_log-2020.05.17-000001 的索引</span><br><span class="line">PUT /%3Cnginx_log-%7Bnow%2Fd%7D-000001%3E</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aliases&quot;: &#123;</span><br><span class="line">    &quot;nginx_log_write&quot;: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是 <code>_rollover</code> api只会对调用该接口的那个时刻有效，当然可以自己独立做一个任务周期性扫描所有别名，当别名到达一定条件后就调用其 <code>_rollover</code> 接口。如果需要es自身定时调用的话，可以使用自动化程度更高的 Index Lifecycle Management。</p>
<h2 id="Index-Lifecycle-Management"><a href="#Index-Lifecycle-Management" class="headerlink" title="Index Lifecycle Management"></a>Index Lifecycle Management</h2><p>与 _rollover 索引相比，索引生命周期管理会更加自动化，ILM把索引的生命周期分为4个phase，分别为Hot、Warm、Cold、Delete。每个phase可以包含多个action。</p>
<table>
<thead>
<tr>
<th>action</th>
<th>允许该action的phase</th>
<th>action意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rollover</td>
<td>hot</td>
<td>和 rollover 索引的条件一致</td>
</tr>
<tr>
<td>Read-Only</td>
<td>warm</td>
<td>通过<code>&quot;index.blocks.write&quot;: false</code> 把原索引会被设置只读</td>
</tr>
<tr>
<td>Allocation</td>
<td>warm, cold</td>
<td>移动索引时指定的亲和性规则，包括include, exclude, require。同时还可以通过 number_of_replicas 变更副本数量，比如指定为0。</td>
</tr>
<tr>
<td>Shrink</td>
<td>warm</td>
<td>合并shard，创建 shrink-${origin_index_name}，前提是需要把原索引的shard移动到同一个node上，需要留意node是否有足够的容量。并且会通过<code>&quot;index.blocks.write&quot;: false</code> 把原索引会被设置只读，并最终删除原索引。</td>
</tr>
<tr>
<td>Force Merge</td>
<td>warm</td>
<td>合并segmemt。和shrink一样，会通过<code>&quot;index.blocks.write&quot;: false</code> 把原索引会被设置只读</td>
</tr>
<tr>
<td>Freeze</td>
<td>cold</td>
<td>冻结索引。适用于很少查询的旧索引，es通过冻结索引能够减少堆内存的使用</td>
</tr>
<tr>
<td>Delete</td>
<td>delete</td>
<td>删除索引</td>
</tr>
<tr>
<td>Set Priority</td>
<td>hot, warm, cold</td>
<td>重启时，恢复索引的优先度，值越大越优先恢复</td>
</tr>
<tr>
<td>Unfollow</td>
<td>hot,warm,cold</td>
<td>应该是中间状态</td>
</tr>
</tbody>
</table>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2020/05/17/es学习系列之一：Rollover-Index-VS-Index-Lifecycle-Management.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2020/01/02/Spark学习系列之三：join的宽依赖vs-窄依赖.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/01/02/Spark学习系列之三：join的宽依赖vs-窄依赖.html" class="post-title-link" itemprop="url">Spark学习系列之三：join的宽依赖vs.窄依赖</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-01-02 01:30:54" itemprop="dateCreated datePublished" datetime="2020-01-02T01:30:54+08:00">2020-01-02</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-17 14:32:49" itemprop="dateModified" datetime="2020-05-17T14:32:49+08:00">2020-05-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>如无特别说明，本文源码版本为 spark 2.3.4<br>两个rdd join时产生新的rdd，是宽依赖，还是窄依赖？</p>
</blockquote>
<h2 id="join-transformation"><a href="#join-transformation" class="headerlink" title="join transformation"></a>join transformation</h2><p><img src="/2020/01/02/Spark学习系列之三：join的宽依赖vs-窄依赖/narrow_wide_dependency.png" alt="narrow_wide_dependency.png"></p>
<p>以上图片是个经常用来解释宽窄依赖的经典图，来源于论文&lt;&lt;Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing&gt;&gt;。以下这段话也来自与该论文：</p>
<blockquote>
<p>join: Joining two RDDs may lead to either two nar- row dependencies (if they are both hash/range partitioned with the same partitioner), two wide dependencies, or a mix (if one parent has a partitioner and one does not). In either case, the output RDD has a partitioner (either one inherited from the parents or a default hash partitioner)</p>
</blockquote>
<p>或许我们会好奇，为什么同样是join操作，有时是宽依赖，有时窄依赖？我们先从两个简单的实验开始，再从源码看其实现方式。</p>
<h3 id="rdd1和rdd2的partitioner不同"><a href="#rdd1和rdd2的partitioner不同" class="headerlink" title="rdd1和rdd2的partitioner不同"></a>rdd1和rdd2的partitioner不同</h3><p>假设我们有rdd1和rdd2，其partitioner分别为partitioner1、partitioner2。分区器定义如下：   </p>
<p>partitioner1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numPartiton = 3</span><br><span class="line">func = x mod numPartiton</span><br></pre></td></tr></table></figure>
<p>partitioner2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numPartiton = 5</span><br><span class="line">func = (x  * 3) mod numPartiton</span><br></pre></td></tr></table></figure>
<p>rdd1的初始分布如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">partition0: (0, &quot;a&quot;), (3, &quot;e&quot;)</span><br><span class="line">partition1: (1, &quot;b&quot;)</span><br><span class="line">partition2: (2, &quot;c&quot;)</span><br></pre></td></tr></table></figure>
<p>rdd2的初始分布如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">partition0: (0, &quot;e&quot;), (0, &quot;j&quot;)</span><br><span class="line">partition1: (2, &quot;f&quot;)</span><br><span class="line">partition2: (4, &quot;g&quot;)</span><br><span class="line">partition3: (1, &quot;h&quot;), (6, &quot;k&quot;)</span><br><span class="line">partition4: (3, &quot;i&quot;)</span><br></pre></td></tr></table></figure>
<p>rdd3=rdd2.join(rdd1)，rdd3数据分布如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">partition0: (0, (&quot;e&quot;, &quot;a&quot;)), (0, (&quot;j&quot;, &quot;a&quot;))</span><br><span class="line">partition1: (2, (&quot;f&quot;, &quot;c&quot;))</span><br><span class="line">partition2: </span><br><span class="line">partition3: (1, (&quot;h&quot;, &quot;b&quot;))</span><br><span class="line">partition4: (3, (&quot;i&quot;, &quot;e&quot;))</span><br></pre></td></tr></table></figure>
<p>rdd3和rdd1以及rdd2的parittion之间的依赖关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rdd1.partition0 ==&gt; rdd3.partition0, rdd3.partition4 </span><br><span class="line">rdd1.partition1 ==&gt; rdd3.partition3  </span><br><span class="line">rdd1.partition2 ==&gt; rdd3.partition2  </span><br><span class="line"></span><br><span class="line">rdd2.partition0 ==&gt; rdd3.partition0  </span><br><span class="line">rdd2.partition1 ==&gt; rdd3.partition1 </span><br><span class="line">rdd2.partition2 ==&gt; rdd3.partition2  </span><br><span class="line">rdd2.partition3 ==&gt; rdd3.partition3  </span><br><span class="line">rdd2.partition4 ==&gt; rdd3.partition4</span><br></pre></td></tr></table></figure>
<p>可以看到rdd1的parittion0 同时被rdd3的partition0和partition4依赖，父rdd的一个parittion被子rdd多个parittion依赖，所以此时rdd3对rdd1的依赖为宽依赖，而对rdd2为窄依赖。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2020/01/02/Spark学习系列之三：join的宽依赖vs-窄依赖.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2019/12/23/使用dbutils作为pymysql的连接池时，setsession偶尔失效的问题.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/23/使用dbutils作为pymysql的连接池时，setsession偶尔失效的问题.html" class="post-title-link" itemprop="url">使用dbutils作为pymysql的连接池时，setsession偶尔失效的问题</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-23 00:03:14" itemprop="dateCreated datePublished" datetime="2019-12-23T00:03:14+08:00">2019-12-23</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-17 14:32:49" itemprop="dateModified" datetime="2020-05-17T14:32:49+08:00">2020-05-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>版本情况dbutils:1.1; pymysql:0.9.3; python:2.7.13</p>
</blockquote>
<h2 id="线上情景"><a href="#线上情景" class="headerlink" title="线上情景"></a>线上情景</h2><p>最近线上维护时，由于只需要更改数据库配置，所以就重启了数据库，而python应用没有重启。在重启数据库后，日志显示正常，也能成功入库。后来接到反馈表示有部分数据没有入库，紧急重启python应用，后续数据入库正常。而我则负责找出原因以及修复bug的工作。</p>
<h2 id="调研原因"><a href="#调研原因" class="headerlink" title="调研原因"></a>调研原因</h2><p>在排查完其他问题后，最异常的是对于有部分请求，日志显示处理成功了，但是却没入库，排查了好几天找不到原因。为此写了demo来帮助排查，为了可以自动commit，采用的是setsession=[“set autocommit=1”]方式设置每个底层的连接为自动提交。在测试demo期间，数据库重启后之后的sql就无法入库。demo代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">from</span> DBUtils.PooledDB <span class="keyword">import</span> PooledDB</span><br><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> MySQLError</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br><span class="line">con = <span class="keyword">None</span></span><br><span class="line">pooledDB = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_insert</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"============ &#123;0&#125; ============"</span>.format(i)</span><br><span class="line">        <span class="comment"># 除了第一次从库中拿，不用ping，直接接初始化链接</span></span><br><span class="line">        <span class="comment"># 后面如果有cache connection，则从cache中并且进行ping，如果失败则用_create()重新初始化connection</span></span><br><span class="line">        <span class="comment"># con 类型为 PooledDedicatedDBConnection</span></span><br><span class="line">        <span class="comment"># con._con 类型为 SteadyDBConnection</span></span><br><span class="line">        <span class="comment"># con._con._con 类型为 pymysql中的Connection类型</span></span><br><span class="line">        <span class="comment"># con._con._con._sock 类型为 mysql 连接</span></span><br><span class="line">        con = pooledDB.connection()</span><br><span class="line">        <span class="comment"># con._con._con.autocommit(True)</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"con._con id = &#123;0&#125;"</span>.format(id(con._con))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"con._con._con id = &#123;0&#125;"</span>.format(id(con._con._con))</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"con._con._con._sock id = &#123;0&#125;"</span>.format(id(con._con._con._sock))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor = con.cursor(pymysql.cursors.DictCursor)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cursor:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"cursor is &#123;0&#125;"</span>.format(cursor)</span><br><span class="line">            select_sql = <span class="string">"insert into user2(name,age) values('zhang', 20)"</span></span><br><span class="line">            ret_rows = cursor.execute(select_sql)</span><br><span class="line">            <span class="keyword">print</span> cursor._last_executed</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"ret_rows is &#123;0&#125;"</span>.format(ret_rows)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> MySQLError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"MySQLError error: &#123;0&#125;"</span>.format(e)</span><br><span class="line">            <span class="keyword">print</span> traceback.format_exc()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"Exception error: &#123;0&#125;"</span>.format(e)</span><br><span class="line">            <span class="keyword">print</span> traceback.format_exc()</span><br><span class="line"></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        con.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    db_conf = &#123;<span class="string">'user'</span>:<span class="string">'root'</span>,<span class="string">'passwd'</span>:<span class="string">'zhang'</span>,<span class="string">'host'</span>:<span class="string">'127.0.0.1'</span>,<span class="string">'port'</span>:<span class="number">3306</span>,<span class="string">'connect_timeout'</span>:<span class="number">5</span>,<span class="string">'db'</span>:<span class="string">'test_dbutils'</span>&#125;</span><br><span class="line">    <span class="comment"># db_conf = &#123;'user':'root','passwd':'zhang','host':'127.0.0.1','port':3306,'connect_timeout':5,'db':'test_dbutils',"autocommit":True&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pooledDB = PooledDB(</span><br><span class="line">        creator=pymysql,  <span class="comment"># 使用数据库连接的模块</span></span><br><span class="line">        maxconnections=<span class="number">4</span>,  <span class="comment"># 连接池允许的最大连接数，0和None表示不限制连接数</span></span><br><span class="line">        mincached=<span class="number">0</span>,  <span class="comment"># 初始化时，连接池中至少创建的空闲的链接，0表示不创建</span></span><br><span class="line">        maxcached=<span class="number">0</span>,  <span class="comment"># 连接池中最多闲置的链接，0和None不限制</span></span><br><span class="line">        maxshared=<span class="number">0</span>,  <span class="comment"># 连接池中最多共享的链接数量，0表示不共享。PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，此值只有在creator.threadsafety &gt; 1时设置才有效，否则创建的都是dedicated connection，即此连接是线程专用的。</span></span><br><span class="line">        blocking=<span class="keyword">True</span>,  <span class="comment"># 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错</span></span><br><span class="line">        maxusage=<span class="keyword">None</span>,  <span class="comment"># 一个连接最多被重复使用的次数，None表示无限制</span></span><br><span class="line">        setsession=[<span class="string">"set autocommit=1"</span>],  <span class="comment"># 开始会话前执行的命令列表。如：["set datestyle to ...", "set time zone ..."]；务必要设置autocommit，否则可能导致该session的sql未提交</span></span><br><span class="line">        ping=<span class="number">1</span>,  <span class="comment"># 每次从pool中取连接时ping一次检查可用性</span></span><br><span class="line">        reset=<span class="keyword">False</span>,  <span class="comment"># 每次将连接放回pool时，将未提交的内容回滚；False时只对事务操作进行回滚</span></span><br><span class="line">        **db_conf</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    try_insert()</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/12/23/使用dbutils作为pymysql的连接池时，setsession偶尔失效的问题.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2019/12/22/Spark学习系列之二：rdd分区数量分析.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/22/Spark学习系列之二：rdd分区数量分析.html" class="post-title-link" itemprop="url">Spark学习系列之二：rdd分区数量分析</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-22 01:43:42" itemprop="dateCreated datePublished" datetime="2019-12-22T01:43:42+08:00">2019-12-22</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-17 14:32:49" itemprop="dateModified" datetime="2020-05-17T14:32:49+08:00">2020-05-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>如无特别说明，本文源码版本为 spark 2.3.4</p>
</blockquote>
<p>创建rdd有三种方式，一种是通过SparkContext.textFile()访问外部存储创建，一种是通过输入数据集合通过调用 SparkContext.parallelize() 方法来创建，最后一种是通过转换已有的rdd生成新的rdd。</p>
<h2 id="通过parallelize创建rdd的分区数量分析"><a href="#通过parallelize创建rdd的分区数量分析" class="headerlink" title="通过parallelize创建rdd的分区数量分析"></a>通过parallelize创建rdd的分区数量分析</h2><p>通过parallelize的方式比较简单，相信也是大部分初学者第一次接触创建rdd的方法，那么通过这个方法创建的rdd的默认分区数是多少呢？我们通过源码进行分析。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.spark.<span class="type">SparkContext</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparkContext</span>(<span class="params">config: <span class="type">SparkConf</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Default level of parallelism to use when not given by user (e.g. parallelize and makeRDD). */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">defaultParallelism</span></span>: <span class="type">Int</span> = &#123;</span><br><span class="line">    assertNotStopped()</span><br><span class="line">    taskScheduler.defaultParallelism</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parallelize</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      seq: <span class="type">Seq</span>[<span class="type">T</span>],</span><br><span class="line">      numSlices: <span class="type">Int</span> = defaultParallelism): <span class="type">RDD</span>[<span class="type">T</span>] = withScope &#123;</span><br><span class="line">    assertNotStopped()</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ParallelCollectionRDD</span>[<span class="type">T</span>](<span class="keyword">this</span>, seq, numSlices, <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">String</span>]]())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看看parallelize是如何生成rdd的。可以看到它是通过 ParallelCollectionRDD 类创建一个rdd，其内部返回的partitioner是通过ParallelCollectionRDD伴生对象的slice方法分割seq为一个二维的Seq[Seq[T]]，并把这个二维的序列传递到ParallelCollectionPartition中实例化的。</p>
<p>接下来是关键，<code>defaultParallelism</code>的默认值确定了分区的数量。</p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/12/22/Spark学习系列之二：rdd分区数量分析.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2019/12/16/Spark学习系列之一：新手常见问题.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/16/Spark学习系列之一：新手常见问题.html" class="post-title-link" itemprop="url">Spark学习系列之一：新手常见问题</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-16 02:00:19" itemprop="dateCreated datePublished" datetime="2019-12-16T02:00:19+08:00">2019-12-16</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-17 14:32:49" itemprop="dateModified" datetime="2020-05-17T14:32:49+08:00">2020-05-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>如无特别说明，本文源码版本为 spark 2.3.4</p>
</blockquote>
<p>学习spark有一段时间了，最近想动动手写个<a href="https://github.com/salmon7/spark-and-scala-learning" target="_blank" rel="noopener">demo</a>出来，大致的功能是从kafka读取用户点击记录，用spark streaming对这些数据进行读取并统计用户一段时间的点击记录，期望最后能落盘到redis中供需求方调用。</p>
<p>这个demo看似简单，但是作为一个新手，我也遇到了一些看起来比较奇怪的问题。再此总结一下我遇到的一些问题，希望能给遇到同样问题的人带来一些帮助。</p>
<h2 id="问题一：spark的并行度是多少？"><a href="#问题一：spark的并行度是多少？" class="headerlink" title="问题一：spark的并行度是多少？"></a>问题一：spark的并行度是多少？</h2><p>我相信一开始接触的初学者对此肯定有疑惑，并行度指的什么？我认为在spark中，这个并行度指的是partition的数量，无论是通过parallelize初始化rdd，还是通过join和reduceByKey等shuffle操作，都意味着需要确定这个新rdd的paritition数量。这里涉及到一个参数<code>spark.default.parallelism</code>，该参数<strong>大多数情况下</strong>是parallelize、join、reducdeByKey等操作的<strong>默认</strong>并行度。如果不定义这个参数，默认情况下分区数量在不同情景的情况下有所不同：</p>
<ul>
<li>对于join和reduceByKey等shuffle操作，分区数一般为多个父rdd中partition数目最大的一个。</li>
<li>对于parallelize进行初始化操作，分区数在不同部署模式下不同：<ul>
<li>local[*]：本地cpu的core数量，local[N]则为N，local则为1</li>
<li>meos：默认为8</li>
<li>other：一般为executor个数 * 每个executor的core个数</li>
</ul>
</li>
<li>当然如果定义了<code>spark.default.parallelism</code>参数，其默认分区数也不一定是其值，具体分析见<a href="/2019/12/22/Spark学习系列之二：rdd分区数量分析.html">Spark学习系列之二：rdd分区数量分析</a>。实际api中也能通过传递numPartitions参数覆盖<code>spark.default.parallelism</code>，自行决定并行度。</li>
<li>比如正在使用的mac是四核，假设向yarn申请executor个数为2，每个executor的core数量为1，那么spark.default.parallelism的值为2，这时一般情况下是不能充分利用其申请核数资源的，最好是申请核数的2~3倍。可以通过 –conf 传入参数 <code>--conf spark.default.parallelism = 4</code> 或者 <code>--conf spark.default.parallelism = 6</code>，使其默认值为申请核数的2~3倍。如果有的task执行比较快，core就空闲出来了，为了多利用core就设置task数量为2~3倍。当然最后的并行度还需要根据实际情况进行分析。</li>
</ul>
<blockquote>
<p>如何确定本机核数？通过local[*]模式进行parallelize初始化rdd，再输出myrdd.partitions.size即可得，也可以通过java代码Runtime.getRuntime.availableProcessors()获得</p>
</blockquote>
<p>参考：<br><a href="https://spark.apache.org/docs/latest/configuration.html" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/configuration.html</a><br><a href="http://spark.apache.org/docs/latest/tuning.html" target="_blank" rel="noopener">http://spark.apache.org/docs/latest/tuning.html</a></p>
<h2 id="问题二：standalone模式下，executor个数和executor核数如何确定？"><a href="#问题二：standalone模式下，executor个数和executor核数如何确定？" class="headerlink" title="问题二：standalone模式下，executor个数和executor核数如何确定？"></a>问题二：standalone模式下，executor个数和executor核数如何确定？</h2><p>由于需要通过spark streaming读取kafka，如果对应topic的partition数量已知，那么应该启动对应个数的executor，因为kafka的一个parition同一时间只允许同一个groupid的consumer读取，如果topic的partition为1，申请的executor为2，那么将只有一个executor的资源得到了利用。</p>
<p>既然executor个数比较重要，yarn模式可以通过<code>--num-executors</code>确定executor个数，那standalone模式如何确定的呢？直接先说结论：</p>
<ul>
<li>executor的数量 = total-executor-cores/executor-cores</li>
<li><code>--total-executor-cores</code> 对应配置 <code>spark.cores.max</code> (default: <code>spark.deploy.defaultCores</code>)，表示一个application最大能用的core数目；如果没有设置则默认上限为<code>spark.deploy.defaultCores</code>，该配置的值默认为infinite（不限）</li>
<li><code>--executor-cores</code> 对应配置 <code>spark.executor.cores</code>，表示每个executor的core数目</li>
<li>可以看到standalone的executor数量并不能直接指定，而是通过core的换算得到的，如果对executor数目有要求的话，可以额外关注一下。</li>
</ul>
<blockquote>
<p>以下是我写demo过程遇到问题，以及解决问题的大致流程。</p>
</blockquote>
<p>在写demo过程中通过spark-sumbit提交任务时，忘了写master，但是通过<code>--executor-cores</code>指定了每个executor的core数量。等应用跑起来后，发现spark ui上，发现worker上有1个executor，每个executor4个core，这显然不符合的预期。明明通过<code>--executor-cores</code>指定了executor的core数量，为什么申请到的core数目不符合预期？即使spark-submit的script中没包含master，但是程序是指定了master（spark://zhangqilongdeMacBook-Air.local:7077）。我决定进行多次调整参数，验证每种情况下申请到executor数量和每个executor的core数量，总结如下：</p>
<ul>
<li>master和executor-cores，只配置一个或者两个都不配，则只申请一个executor，并且executor将尽量使用worker的所有core。</li>
<li>master和executor-cores两个都配，则申请的executor数量 = workder core的总数/executor-cores，每个executor的core数量和executor-cores一致。</li>
</ul>
<p>通过源码可以发现：</p>
<ul>
<li><code>--executor-cores</code>只有在–master为standalone、yarn、kubernetes模式下才会生效，如果不是这些模式，将会通过<strong>默认配置文件</strong>指定缺失的值。即如果不指定master的情况下（默认为local[*]），<code>--executor-cores</code>并不会生效，并且使用 <code>SPAKR_HOME/conf/spark-defaults.conf</code>配置文件中的值对其赋值，如果该配置文件中依然不存在，则为spark系统默认对该变量的值，即infinite（不限）。</li>
<li><code>--total-executor-cores</code>可以配置standalone每个application可以用的核总数（其实通过spark-submit命令行的提示也能看出来，因为yarn模式下该值不可配所以一开始这个配置被我忽略了）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">org.apache.spark.deploy.<span class="type">Submit</span></span><br><span class="line"></span><br><span class="line">...省略部分代码</span><br><span class="line">	<span class="comment">//可以看到spark.executor.cores只在某些情况下才会被赋值</span></span><br><span class="line">	<span class="type">OptionAssigner</span>(args.executorCores, <span class="type">STANDALONE</span> | <span class="type">YARN</span> | <span class="type">KUBERNETES</span>, <span class="type">ALL_DEPLOY_MODES</span>, confKey = <span class="string">"spark.executor.cores"</span>),</span><br><span class="line">	<span class="type">OptionAssigner</span>(args.totalExecutorCores, <span class="type">STANDALONE</span> | <span class="type">MESOS</span> | <span class="type">KUBERNETES</span>, <span class="type">ALL_DEPLOY_MODES</span>, confKey = <span class="string">"spark.cores.max"</span>)</span><br><span class="line"></span><br><span class="line">...省略部分代码</span><br><span class="line">    <span class="comment">// Load any properties specified through --conf and the default properties file</span></span><br><span class="line">    <span class="comment">// 通过sparkProperties（已经读取了spark-defaluts.conf内动）hashMap对缺失配置进行填充。</span></span><br><span class="line">    <span class="keyword">for</span> ((k, v) &lt;- args.sparkProperties) &#123;</span><br><span class="line">      sparkConf.setIfMissing(k, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...省略部分代码</span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="https://spark.apache.org/docs/latest/spark-standalone.html" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/spark-standalone.html</a></p>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/12/16/Spark学习系列之一：新手常见问题.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2019/11/10/golang数据库连接broken-pipe异常原因分析及解决.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/10/golang数据库连接broken-pipe异常原因分析及解决.html" class="post-title-link" itemprop="url">golang数据库连接broken pipe异常原因分析及解决</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-10 21:57:03" itemprop="dateCreated datePublished" datetime="2019-11-10T21:57:03+08:00">2019-11-10</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-17 14:32:49" itemprop="dateModified" datetime="2020-05-17T14:32:49+08:00">2020-05-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>在golang开发中，在使用mysql数据库时一般使用数据库驱动包为 go-sql-driver/mysql，该包是按照go官方包database/sql定义规范实现的。我们线上的程序偶尔会在标准错误输出 “broken pip”，为了究其原因做了些调研，并给出了解决方法。</p>
</blockquote>
<h2 id="线上场景"><a href="#线上场景" class="headerlink" title="线上场景"></a>线上场景</h2><p>目前 <strong>项目A</strong> 使用的go-sql-driver/mysql版本为 <strong>3654d25ec346ee8ce71a68431025458d52a38ac0</strong> ， <strong>项目B</strong> 使用的版本为 <strong>v1.3.0</strong> ，其中 <strong>项目A</strong> 的版本低于v1.3.0。它们线上标准错误输出都有类似以下的日志，但是程序的业务逻辑却没有影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysql] 2019/08/01 17:12:18 packets.go:33: unexpected EOF</span><br><span class="line">[mysql] 2019/08/01 17:12:18 packets.go:130: write tcp 127.0.0.1:59722-&gt;127.0.0.1:3306: write: broken pipe</span><br></pre></td></tr></table></figure>
<p>通过日志输出以及堆栈可以找到 <code>go-sql-driver/mysql/packets.go</code> 对应的源码，可以发现第一条日志是以下第8行代码打印，第二条是第9行调用<code>mc.Close()</code>关闭连接时报错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read packet to buffer 'data'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *mysqlConn)</span> <span class="title">readPacket</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> prevData []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// read packet header</span></span><br><span class="line">        data, err := mc.buf.readNext(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            errLog.Print(err)</span><br><span class="line">            mc.Close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, driver.ErrBadConn</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><blockquote>
<p>通过网上搜索能够大概猜出是mysql server主动关闭的原因，我们可以通过设置mysql server主动关闭连接来复现线上场景，并且通过tcpdump观察其原因。</p>
</blockquote>
<h3 id="1-设置mysql-server主动关闭连接时间"><a href="#1-设置mysql-server主动关闭连接时间" class="headerlink" title="1.设置mysql server主动关闭连接时间"></a>1.设置mysql server主动关闭连接时间</h3><p>mysql server默认设置的关闭不活跃连接时间为28800秒（8小时），我们通过 <code>set global wait_time=10</code> 设置为10秒，便于问题重现。</p>
<h3 id="2-运行tcpdump和测试demo"><a href="#2-运行tcpdump和测试demo" class="headerlink" title="2.运行tcpdump和测试demo"></a>2.运行tcpdump和测试demo</h3><p>1.通过tcpdump可以收集tcp数据包的发送接收情况，尤其是的在mysql server关闭连接后，go程序如何和mysql server交互是我们关注的重点，tcpdump命令如下：</p>
<p><code>sudo tcpdump -s 0 -t -i lo -l port 3306 -w lo.cap</code></p>
<p>2.运行一个简单的测试demo</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"database/sql"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    _ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// before you run this test program, please run the script in your mysql</span></span><br><span class="line">    <span class="comment">// "set global wait_timeout=10;"</span></span><br><span class="line">    <span class="comment">// 表示mysql server关闭不活跃连接的等待时间</span></span><br><span class="line">    <span class="comment">// 参考 https://github.com/go-sql-driver/mysql/issues/657</span></span><br><span class="line">    db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:zhang@tcp(127.0.0.1:3306)/?charset=latin1&amp;autocommit=1&amp;parseTime=true&amp;loc=Local&amp;timeout=3s"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line">    <span class="comment">//db.SetConnMaxLifetime(5 * time.Second)</span></span><br><span class="line">    err = db.Ping()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            _, err := db.Exec(<span class="string">"select * from test_time.A"</span>)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Wait for 11 seconds. This should be enough to timeout the conn, since `wait_timeout` is 10s</span></span><br><span class="line">            time.Sleep(<span class="number">11</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">1000</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/11/10/golang数据库连接broken-pipe异常原因分析及解决.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.zhang7long.com/2019/11/09/浅谈golang对mysql时间类型数据转换的问题.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Long">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="keep running">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/09/浅谈golang对mysql时间类型数据转换的问题.html" class="post-title-link" itemprop="url">浅谈golang对mysql时间类型数据转换的问题</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-09 22:19:22" itemprop="dateCreated datePublished" datetime="2019-11-09T22:19:22+08:00">2019-11-09</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2020-05-17 14:32:49" itemprop="dateModified" datetime="2020-05-17T14:32:49+08:00">2020-05-17</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>部门某些业务需要在海外上线，涉及到数据库时区、应用时区的转换。本文将讨论golang针对数据库时区的处理问题。</p>
<blockquote>
<p>为了方便讨论，避免混淆，本文对“时间”的表达方式作出约定：时间=时区时间+时区。如时间 2019-05-21 15:48:38 CST ,则其时区时间为2019-05-21 15:48:38，时区为CST。如果没有特别说明，本文提到的“时间”都包含时区。</p>
</blockquote>
<h2 id="一、golang中mysql数据库驱动的时区配置"><a href="#一、golang中mysql数据库驱动的时区配置" class="headerlink" title="一、golang中mysql数据库驱动的时区配置"></a>一、golang中mysql数据库驱动的时区配置</h2><p>mysql中关于时间日期的概念数据模型有<code>DATE</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>，golang程序根据数据链接DSN（Data Source Name）配置，数据库驱动 github.com/go-sql-driver/mysql 可以对这三种类型的值转换成go中的time.Time类型，关键配置如下：</p>
<ul>
<li>parseTime<ul>
<li>默认为false，把mysql中的 <code>DATE</code>、<code>DATETIME</code>、<code>TIMESTAMP</code> 转为golang中的[]byte类型</li>
<li>设置为true，将会转为golang中的 <code>time.Time</code> 类型</li>
</ul>
</li>
<li>loc<ul>
<li>默认为UTC，表示转换<code>DATE</code>、<code>DATETIME</code>、<code>TIMESTAMP</code> 为 <code>time.Time</code> 时所使用的时区</li>
<li>设置成Local，则与系统设置的时区一致</li>
<li>如果想要设置成中国时区可以设置成 <code>Asia/Shanghai</code> ，更多的时区可以参考 <code>/usr/share/zoneinfo/</code> 或者<code>$GOROOT/lib/time/zoneinfo.zip</code>。</li>
</ul>
</li>
</ul>
<p>在实际的使用中，我们往往会配置成 <code>parseTime=true</code> 和 <code>loc=Local</code>，这样避免了手动转换<code>DATE</code>、<code>DATETIME</code>、<code>TIMESTAMP</code>。</p>
<h2 id="二、golang如何转换mysql的时间类型"><a href="#二、golang如何转换mysql的时间类型" class="headerlink" title="二、golang如何转换mysql的时间类型"></a>二、golang如何转换mysql的时间类型</h2><blockquote>
<p>在涉及到不同时区时，我们golang程序应该怎么处理mysql的 DATE、DATETIME、TIMESTAMP 数据类型？是否只要配置了parseTime=true&amp;loc=xxx就不会有问题？我们来做两个小实验。</p>
</blockquote>
<h3 id="实验一：应用和数据库在同一时区"><a href="#实验一：应用和数据库在同一时区" class="headerlink" title="实验一：应用和数据库在同一时区"></a>实验一：应用和数据库在同一时区</h3><h4 id="1-timestamp"><a href="#1-timestamp" class="headerlink" title="1.timestamp"></a>1.timestamp</h4><p>a.系统时区设置为CST，mysql和golang在同一个时区的机器上。（如何设置和查看时区可以参考本文第五节内容。）</p>
<ul>
<li>golang在程序中连接数据库使用的配置DSN是parseTime=true&amp;loc=xxx，xxx分别为UTC、Asia/Shanghai、Europe/London、Local。</li>
<li>mysql终端中insert一条timestamp【时区时间】为2019-04-02 13:18:17的记录，其UNIX_TIMESTAMP(timestamp)=1554182297。</li>
</ul>
<p>以下1~5行均为golang程序读取刚插入数据库的数据结果，第一列输出分别为链接数据库DSN配置，第二列为转换为time.Time后的输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parseTime=true&amp;loc=UTC:                  2019-04-02 13:18:17 +0000 UTC</span><br><span class="line">parseTime=true&amp;loc=Asia/Shanghai:        2019-04-02 13:18:17 +0800 CST</span><br><span class="line">parseTime=true&amp;loc=Europe/London:        2019-04-02 13:18:17 +0100 BST</span><br><span class="line">parseTime=true&amp;loc=Local:                2019-04-02 13:18:17 +0800 CST</span><br></pre></td></tr></table></figure>
<p>b.同样的机器，修改系统时区为BST，在mysql终端中select上一步插入的数据，timestamp【时区时间】为2019-04-02 06:18:17，UNIX_TIMESTAMP(timestamp)=1554182297。程序输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parseTime=true&amp;loc=UTC:                  2019-04-02 06:18:17 +0000 UTC</span><br><span class="line">parseTime=true&amp;loc=Asia/Shanghai:        2019-04-02 06:18:17 +0800 CST</span><br><span class="line">parseTime=true&amp;loc=Europe/London:        2019-04-02 06:18:17 +0100 BST</span><br><span class="line">parseTime=true&amp;loc=Local:                2019-04-02 06:18:17 +0100 BST</span><br></pre></td></tr></table></figure>
<p>c.小结：</p>
<ul>
<li>UNIX_TIMESTAMP可以把mysql的timstamp转为距离 1970-01-01 00:00:00 UTC 的秒数，这个经过转换后的值无论mysql在任何时区都不会变。</li>
<li>即使同一条数据库记录，由于时区不同，mysql终端中直接select出的timestamp的【时区时间】也不同。也侧面说明了mysql内部实现的timstamp结构体中包含了时区信息，在输出时根据当前时区做转换，输出当前【时区时间】。</li>
<li>golang程序获取到的time.Time等于：mysql【时区时间】+ 时区，时区为loc指定的时区，与mysql时区没有关系。</li>
</ul>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2019/11/09/浅谈golang对mysql时间类型数据转换的问题.html#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Long</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/salmon7" title="GitHub &rarr; https://github.com/salmon7" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:qilong_zhang@163.com" title="E-Mail &rarr; mailto:qilong_zhang@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Long</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
      
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
